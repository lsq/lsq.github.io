<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Complete Sed Command Guide | lsq 的博客</title>

    
<link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" />




<meta name="author" content="lsq" />
<meta name="description" content="Complete Sed Command Guide [Explained with Practical Examples] In a previous article, I showed the basic usage of Sed, the stream editor, on a practical use case. Today, be prepared to gain more insight about Sed as we will take an in-depth tour of the sed execution model. This will be also an opportunity to make an exhaustive review of all Sed commands and to dive into their details and subtleties." />



<meta name="generator" content="Hugo 0.97.3" />

<link rel="canonical" href="https://lsq.github.io/posts/sed-reference-guide/" />


<meta property="og:title" content="Complete Sed Command Guide" />
<meta property="og:description" content="Complete Sed Command Guide [Explained with Practical Examples] In a previous article, I showed the basic usage of Sed, the stream editor, on a practical use case. Today, be prepared to gain more insight about Sed as we will take an in-depth tour of the sed execution model. This will be also an opportunity to make an exhaustive review of all Sed commands and to dive into their details and subtleties." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lsq.github.io/posts/sed-reference-guide/" /><meta property="og:image" content="https://lsq.github.io/images/Sed_Command_Guide.jpg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-18T18:04:57+08:00" />
<meta property="article:modified_time" content="2019-11-18T18:04:57+08:00" />




<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://lsq.github.io/images/Sed_Command_Guide.jpg"/>

<meta name="twitter:title" content="Complete Sed Command Guide"/>
<meta name="twitter:description" content="Complete Sed Command Guide [Explained with Practical Examples] In a previous article, I showed the basic usage of Sed, the stream editor, on a practical use case. Today, be prepared to gain more insight about Sed as we will take an in-depth tour of the sed execution model. This will be also an opportunity to make an exhaustive review of all Sed commands and to dive into their details and subtleties."/>


<link rel="stylesheet" href="/css/semantic.min.css" />
<link rel="stylesheet" href="/css/icomoon.css" />
<link rel="stylesheet" href="/css/OverlayScrollbars.min.css" />
<link rel="stylesheet" href="/css/github-markdown.css" />
<link rel="stylesheet" href="/css/site.css" />

<style>
  a:not(.ui.button):hover {
    text-decoration: underline;
  }

  
  a:not(.ui.button) {
    color: seagreen !important;
  }
  

  
  .inverted a:not(.ui.button),
  .inverted a:not(.ui.button):hover {
     color: darkseagreen !important;
  }
  

  
  body.default {
    
    background-color: #fff;
    

    
    background-image: url(/me/background.jpg);
    
  }
  

  
  body.dark {
    

    
    background-image: url(/me/background.jpg);
    
  }
  
</style>


    



<link rel="stylesheet" data-highlight href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/tomorrow.min.css" />







    
    <link rel="stylesheet" href="/css/custom.css" />
    
  </head>

  <body class="default">
    
<nav class="ui secondary menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="翻转！"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="首页" onclick="window.location.href = 'https:\/\/lsq.github.io'"></i>
  </div>
  
  <div class="item">
    <i class="large link icon theme-switch" onclick="themeSwitch()"></i>
  </div>
  
  
  <div class="item">
    <i class="large link search icon" onclick="toggleSearch()"></i>
  </div>
  
</nav>

    <div class="flip-container">
      <div class="flipper">
        <section class="front">
          <div class="dream-max-width">
            
<div class="ui relaxed grid dream-grid dream-grid-single">
  <aside class="sixteen wide mobile sixteen wide tablet four wide computer column dream-single-aside">
    
    
    <div class="ui segment toc">
      <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#a-little-bit-of-theory-on-sed">A little bit of theory on Sed</a></li>
        <li><a href="#a-first-look-at-the-sed-execution-model">A first look at the sed execution model</a></li>
        <li><a href="#the-sed-abstract-machine-a-namethe-sed-abstract-machine-a">The Sed abstract machine <a name="the-sed-abstract-machine" ></a></a></li>
        <li><a href="#a-more-accurate-sed-execution-model">A more accurate Sed execution model</a></li>
      </ul>
    </li>
    <li><a href="#the-print-command"><a name="the-print-command"></a>
The print command</a></li>
    <li><a href="#addresses">Addresses</a>
      <ul>
        <li><a href="#line-numbers">Line numbers</a></li>
        <li><a href="#regular-expressions">Regular expressions</a></li>
        <li><a href="#extended-regular-expressions">Extended regular expressions</a></li>
        <li><a href="#the-bracket-quantifier">The bracket quantifier</a></li>
        <li><a href="#range-addresses">Range addresses</a></li>
        <li><a href="#a-namecomplementcomplementa"><a name="complement">Complement</a></a></li>
        <li><a href="#conjunctions">Conjunctions</a></li>
      </ul>
    </li>
    <li><a href="#the-quit-command"><a name="the-quit-command"></a>
The quit command</a></li>
    <li><a href="#the-substitution-command"><a name="substitution"></a>
The substitution command</a>
      <ul>
        <li><a href="#the-delete-command">The delete command</a></li>
        <li><a href="#the-next-command">The next command</a></li>
      </ul>
    </li>
    <li><a href="#working-with-the-hold-space"><a name="working-with-the-hold-space"></a>
Working with the hold space</a>
      <ul>
        <li><a href="#the-exchange-command">The exchange command</a></li>
        <li><a href="#the-hold-commands">The hold commands</a></li>
        <li><a href="#the-get-command">The get command</a></li>
      </ul>
    </li>
    <li><a href="#print-delete-and-next-revisited"><a name="print-delete-and-next-revisited"></a>
print, delete and next revisited</a></li>
    <li><a href="#branching"><a name="branches"></a>
Branching</a>
      <ul>
        <li><a href="#labels-and-branches">labels and branches</a></li>
        <li><a href="#conditional-branch">Conditional branch</a></li>
      </ul>
    </li>
    <li><a href="#handling-verbatim-text"><a name="handling-verbatim-text"></a>
Handling verbatim text</a>
      <ul>
        <li><a href="#the-change-command">The change command</a></li>
        <li><a href="#the-insert-command">The insert command</a></li>
        <li><a href="#the-append-command">The append command</a></li>
        <li><a href="#the-read-command">The read command</a></li>
      </ul>
    </li>
    <li><a href="#alternate-output"><a name="alternate-output"></a>
Alternate output</a>
      <ul>
        <li><a href="#the-write-command">The write command</a></li>
        <li><a href="#the-substitution-command-write-flag">The substitution command <code>write</code> flag</a></li>
      </ul>
    </li>
    <li><a href="#comments"><a name="comment"></a>
Comments</a></li>
    <li><a href="#the-commands-you-will-rarely-need"><a name="the-commands-you-will-rarely-need"></a>
The commands you will rarely need</a>
      <ul>
        <li><a href="#the-line-number-command">The line number command</a></li>
        <li><a href="#the-unambiguous-print-command">The unambiguous print command</a></li>
        <li><a href="#the-transliterate-command">The transliterate command</a></li>
      </ul>
    </li>
    <li><a href="#the-last-word"><a name="the-last-word"></a>
The last word</a></li>
  </ul>
</nav>
    </div>
    
    <div class="ui segment actions">
      <button
        class="ui circular icon button save-as-image"
        title="保存为图片"
        onclick="savePostAsImg()">
        <i class="save icon"></i>
      </button>

      <a href="https://twitter.com/intent/tweet?text=Complete%20Sed%20Command%20Guide&url=https%3a%2f%2flsq.github.io%2fposts%2fsed-reference-guide%2f" class="ui circular twitter icon button">
  <i class="twitter icon"></i>
</a>
<a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flsq.github.io%2fposts%2fsed-reference-guide%2f" class="ui circular facebook icon button">
  <i class="facebook icon"></i>
</a>

    </div>
  </aside>
  <div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single" id="dream-save-post-as-img">
    
    <div class="ui top attached segment cover">
      <div class="cover-img" style="background-image: url(/images/Sed_Command_Guide.jpg);"></div>
    </div>
    
    <section class="ui attached segment">
      <header>
        <h1 class="ui large header">Complete Sed Command Guide<div class="sub header">
            @
            
              lsq
            

            | 
                星期一，十一月 18 日，2019 年
              

            | 40 分钟阅读

            | 更新于
              
                星期一，十一月 18 日，2019 年
              
          </div>
        </h1>
      </header>

      <article class="main"><h1 id="complete-sed-command-guide-explained-with-practical-examples">Complete Sed Command Guide [Explained with Practical Examples]</h1>
<p>In a previous article, I showed the <a href="https://linuxhandbook.com/sed-command-basics/">basic usage of
Sed</a>, the stream editor,
on a practical use case. Today, be prepared to gain more insight about
Sed as we will take an in-depth tour of the sed execution model. This
will be also an opportunity to make an exhaustive review of all Sed
commands and to dive into their details and subtleties. So, if you are
ready, launch a terminal, <a href="https://gist.github.com/s-leroux/5cb36435bac46c10cfced26e4bf5588c">download the test
files</a>
and sit comfortably before your keyboard: we will start our exploration
right now!</p>
<p>Table of Contents</p>
<ul>
<li><a href="#a-little-bit-of-theory">A little bit of theory</a>
<ul>
<li><a href="#a-first-look-at-the-sed-execution-model">A first look at the sed execution
model</a></li>
<li><a href="#the-sed-abstract-machine">The Sed abstract machine</a></li>
<li><a href="#a-more-accurate-sed-execution-model">A more accurate Sed execution
model</a></li>
</ul>
</li>
<li><a href="#the-print-command">The print command</a></li>
<li><a href="#addresses">Addresses</a>
<ul>
<li><a href="#line-numbers">Line numbers</a></li>
<li><a href="#regex">Regular expressions</a></li>
<li><a href="#extended-regular-expressions">Extended regular expressions</a></li>
<li><a href="#the-bracket-quantifier">The bracket quantifier</a></li>
<li><a href="#range">Range addresses</a></li>
<li><a href="#complement">Complement</a></li>
<li><a href="#conjunctions">Conjunctions</a></li>
</ul>
</li>
<li><a href="#the-quit-command">The quit command</a></li>
<li><a href="#substitution">The substitution command</a>
<ul>
<li><a href="#the-delete-command">The delete command</a></li>
<li><a href="#the-next-command">The next command</a></li>
</ul>
</li>
<li><a href="#working-with-the-hold-space">Working with the hold space</a>
<ul>
<li><a href="#exchange">The exchange command</a></li>
<li><a href="#hold">The hold commands</a></li>
<li><a href="#get">The get command</a></li>
</ul>
</li>
<li><a href="#print-delete-and-next-revisited">print, delete and next
revisited</a></li>
<li><a href="#branches">Branching</a>
<ul>
<li><a href="#labels-and-branches">labels and branches</a></li>
<li><a href="#conditional-branch">Conditional branch</a></li>
</ul>
</li>
<li><a href="#handling-verbatim-text">Handling verbatim text</a>
<ul>
<li><a href="#the-change-command">The change command</a></li>
<li><a href="#the-insert-command">The insert command</a></li>
<li><a href="#the-append-command">The append command</a></li>
<li><a href="#read">The read command</a></li>
</ul>
</li>
<li><a href="#alternate-output">Alternate output</a>
<ul>
<li><a href="#write">The write command</a></li>
<li><a href="#write-flag">The substitution command <code>write</code> flag</a></li>
</ul>
</li>
<li><a href="#comment">Comments</a></li>
<li><a href="#the-commands-you-will-rarely-need">The commands you will rarely
need</a>
<ul>
<li><a href="#the-line-number-command">The line number command</a></li>
<li><a href="#the-unambiguous-print-command">The unambiguous print command</a></li>
<li><a href="#the-transliterate-command">The transliterate command</a></li>
</ul>
</li>
<li><a href="#the-last-word">The last word</a></li>
</ul>
<div id="a-little-bit-of-theory"></div>
<h3 id="a-little-bit-of-theory-on-sed">A little bit of theory on Sed</h3>
<hr>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05/sed-reference-guide.jpeg?resize=800%2C450" alt="complete reference guide to sedcommands"></p>
<h3 id="a-first-look-at-the-sed-execution-model">A first look at the sed execution model</h3>
 <div id="a-first-look-at-the-sed-execution-model"></div>
<p>To truly understand Sed you must first understand the tool execution
model.</p>
<p>When processing data, Sed reads one line of input at a time and stores
it into the so-called <em>pattern space</em>. All Sed’s transformations apply
to the pattern space. Transformations are described by one-letter
commands provided on the command line or in an external Sed script file.
Most Sed commands can be preceded by an address, or an address range, to
limit their scope.</p>
<p>By default, Sed prints the content of the pattern space at the end of
each processing cycle, that is, just before overwriting the pattern
space with the next line of input. We can summarize that model like
that:</p>
<ol>
<li>
<p>Try to read the next input line into the pattern space</p>
</li>
<li>
<p>If the read was successful:</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>a.  Apply in the script order all commands whose address matches the
</span></span><span style="display:flex;"><span>    current input line
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b.  If sed was not launched in quiet mode <span style="color:#f92672">(</span><span style="color:#e6db74">`</span>-n<span style="color:#e6db74">`</span><span style="color:#f92672">)</span> print the content
</span></span><span style="display:flex;"><span>    of the <span style="color:#f92672">(</span>potentially modified<span style="color:#f92672">)</span> pattern space
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>c.  got back to 1.
</span></span></code></pre></div><p>Since the content of the pattern space is lost after each line is
processed, it is not suitable for long-term storage. For that purpose,
Sed has a second buffer, the <em>hold space</em>. Sed never clears, puts or
gets data from the hold space unless you explicitly request it. We will
investigate that more in depth later when studying the
<a href="#exchange">exchange</a>, <a href="#get">get</a> and <a href="#hold">hold</a> commands.</p>
<h3 id="the-sed-abstract-machine-a-namethe-sed-abstract-machine-a">The Sed abstract machine <a name="the-sed-abstract-machine" ></a></h3>
<p>The model explained above is what you will see described in many Sed
tutorials. Indeed, it is correct enough to understand the most basic Sed
programs. But when you start digging into more advanced commands, you
will see it is not sufficient. So let’s try to be a little bit more
formal now.</p>
<p>Actually, Sed can be viewed as implementing an <a href="http://mathworld.wolfram.com/AbstractMachine.html">abstract
machine</a> whose
<a href="https://en.wikipedia.org/wiki/State_(computer_science)">state</a> is
defined by three <a href="https://en.wikipedia.org/wiki/Data_buffer">buffers</a>,
two
<a href="https://en.wikipedia.org/wiki/Processor_register#Categories_of_registers">registers</a>,
and two <a href="https://www.computerhope.com/jargon/f/flag.htm">flags</a>:</p>
<ul>
<li>
<p><strong>three buffers</strong> to store arbitrary length text. Yes: <em>three</em>! In
the basic execution model we talked about the pattern- and
hold-space, but Sed has a third buffer: the <em>append queue</em>. From the
Sed script perspective, it is a write-only buffer that Sed will
flush automatically at predefined moments of its execution (broadly
speaking before reading a new line from the input, or just before
quitting).</p>
</li>
<li>
<p>Sed also maintains <strong>two registers</strong>: the <em>line counter</em> (LC) which
holds the number of lines read from the input, and the <em>program
counter</em> (PC) which always hold the index (“position” in the script)
of the next command to execute. Sed automatically increments the PC
as part of its main loop. But using specific commands, a script can
also directly modify the PC to skip or repeat parts of the program.
This is how loops or conditional statements can be implemented with
Sed. More on that in the dedicated <a href="#branches">branches section</a>
below.</p>
</li>
<li>
<p>Finally <strong>two flags</strong> can modify the behavior of certain Sed
commands: the <em>auto-print flag</em> (AP) the <em>substitution flag</em> (SF).
When the auto-print flag is <em>set</em>, Sed will automatically print the
content of the pattern space <em>before</em> overwriting it (notably before
reading a new line of input but not only). When the auto-print flag
is <em>clear</em> (“not set”), Sed will never print the content of the
pattern space without an explicit command in the script. You can
clear the auto-print flag by running Sed in “quiet mode” (using the
<code>-n</code> command line option or by using the <a href="#comment">special
comment</a><code>#n</code> on the very first line or the script). The
“substitution flag” is set by the <a href="#substitution">substitution
command</a> (the <code>s</code> command) when both its address and
search pattern match the content of the pattern space. The
substitution flag is cleared at the start of each new cycle, or when
a new line is read from input, or after a conditional branch is
taken. Here again, we will revisit that topic in details in the
<a href="#branches">branches section</a>.</p>
</li>
</ul>
<p>In addition, Sed maintains the list of commands having entered their
address range (more on that of the <a href="#range">range addresses</a> section) as
well as a couple of file handles to read and write data. You will find
some more information on that in the <a href="#read">read</a> and <a href="#write">write</a>
command description.</p>
<p><a name="a-more-accurate-sed-execution-model"></a></p>
<h3 id="a-more-accurate-sed-execution-model">A more accurate Sed execution model</h3>
<p>As a picture worth thousands of words, I draw a flowchart describing the
Sed execution model. I left a couple of things aside, like dealing with
multiple input files or error handling, but I think this should be
sufficient for you to understand the behavior of any Sed program and to
avoid wasting your time by groping around while writing your own Sed
scripts.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-flowchart.png" alt="The Sed executionmodel"></p>
<p>You may have noticed I didn’t describe the command-specific actions in
the flowchart above. We will see that in detail for each command. So,
without further ado, let’s start our tour!</p>
<h2 id="the-print-command"><a name="the-print-command"></a>
The print command</h2>
<p>The print command (<code>p</code>) displays the content of the pattern space at the
moment it is executed. It does not change in any way the state of the
Sed abstract machine.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-print-command.png" alt="The Sed \`print\`command"></p>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -e <span style="color:#e6db74">&#39;p&#39;</span> inputfile
</span></span></code></pre></div><p>The command above will print each line of the input file … twice. Once
because you <em>explicitly</em> requested it using the <code>print</code> command, and a
second time <em>implicitly</em> at the end of the processing loop (because we
didn’t launch Sed in “quiet mode” here).</p>
<p>If we are not interested in seeing each line twice, we have two way of
fixing that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;p&#39;</span> inputfile <span style="color:#75715e"># quiet mode with explicit print</span>
</span></span><span style="display:flex;"><span>sed -e <span style="color:#e6db74">&#39;&#39;</span> inputfile  <span style="color:#75715e"># empty &#34;do nothing&#34; program, implicit print</span>
</span></span></code></pre></div><p>Note: the <code>-e</code> option introduces a Sed command. It is used to
distinguish between commands and file names. Since a Sed invocation must
contain at least one command, the <code>-e</code> flag is optional for that first
command. However, I have the habit of using it, mostly for consistency
with more complex cases where I have to give multiple Sed expressions on
the command line. I let you figure by yourself if this is a good or bad
habit, but I will follow that convention in the rest of the article.</p>
<h2 id="addresses">Addresses</h2>
<p>Obviously, the print command is not very useful by itself. However, if
you add an address before the command to apply it only to some lines of
the input file, it suddenly becomes able to filter out unwanted lines
from a file. But what’s an address for Sed? And how are identified the
“lines” of the input file?</p>
<p><a name="line-numbers"></a></p>
<h3 id="line-numbers">Line numbers</h3>
<p>A Sed address can be either a <em>line number</em> (with the extension of <code>$</code>
to mean “the last line”) or a <em>regular expression</em>. When using line
numbers, you have to remember lines are numbered starting from one in
Sed— and not starting from zero.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;1p&#39;</span> inputfile <span style="color:#75715e"># print only the first line of the file</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;5p&#39;</span> inputfile <span style="color:#75715e"># print only the line 5</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;$p&#39;</span> inputfile <span style="color:#75715e"># print the last line of the file</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;0p&#39;</span> inputfile <span style="color:#75715e"># will result in an error because 0 is not a valid line number</span>
</span></span></code></pre></div><p>According to the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html">POSIX
specifications</a>,
line numbers are cumulative if you specify several input files. In other
words, the line counter is not reset when Sed opens a new input file.
So, the two commands below will do the same thing, printing only one
line of text to the output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;1p&#39;</span> inputfile1 inputfile2 inputfile3
</span></span><span style="display:flex;"><span>cat inputfile1 inputfile2 inputfile3 | sed -n -e <span style="color:#e6db74">&#39;1p&#39;</span>
</span></span></code></pre></div><p>Actually, this is exactly how POSIX defines multiple file handling:</p>
<blockquote>
<p>If multiple file operands are specified, the named files shall be read
in the order specified and the concatenation shall be edited.</p>
</blockquote>
<p>However, some Sed implementations offer command line options to change
that behavior, like the GNU Sed <code>-s</code> flag (which is implicitly applied
too when using the GNU Sed <code>-i</code> flags):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -sn -e <span style="color:#e6db74">&#39;1p&#39;</span> inputfile1 inputfile2 inputfile3
</span></span></code></pre></div><p>If your implementation of Sed supports such non-standard options, I let
you check into the <code>man</code> for the details regarding them.</p>
<p><a name="regex"></a></p>
<h3 id="regular-expressions">Regular expressions</h3>
<p>I’ve said Sed addresses could be line numbers or regular expressions.
But what is this <em>regex</em> thing?</p>
<p>In just a few words, a <a href="https://www.regular-expressions.info/">regular
expression</a> is a way to describe
a <em>set</em> of strings. If a given string pertains to the set described by a
regular expression, we said the string matches the regular expression.</p>
<p>A regular expression may contain literal characters that must be present
verbatim into a string to have a match. For example, all letters and
digits behave that way, as well as most printable characters. However,
some symbols have a special meaning:</p>
<ul>
<li>
<p>They could represent anchors, like <code>^</code> and <code>$</code> that respectively
denotes the start or end of a line;</p>
</li>
<li>
<p>other symbols can serve as placeholders for entire sets of
characters (like the dot that matches any single characters or the
square brackets that are used to define a custom character set);</p>
</li>
<li>
<p>others again are quantifiers that serve to denotes repetitions (like
the <a href="https://chortle.ccsu.edu/FiniteAutomata/Section07/sect07_16.html">Kleene
star</a>
that means 0, 1 or several occurrences of the previous pattern).</p>
</li>
</ul>
<p>My goal here is not to give you a regular expression tutorial. So I will
stick with just a few examples. However, feel free to search for more on
the web about that topic: regular expressions are a really powerful
feature available in many standard Unix commands and programming
language and a skill every Unixien should master.</p>
<p>Here are few examples used in the context of a Sed address:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/systemd/p&#39;</span> inputfile <span style="color:#75715e"># print only lines *containing* the literal string &#34;systemd&#34;</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/nologin$/p&#39;</span> inputfile <span style="color:#75715e"># print only lines ending with &#34;nologin&#34;</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/^bin/p&#39;</span> inputfile <span style="color:#75715e"># print only lines starting with &#34;bin&#34;</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/^$/p&#39;</span> inputfile <span style="color:#75715e"># print only empty lines (i.e.: nothing between the start and end of a line)</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/./p&#39;</span> inputfile <span style="color:#75715e"># print only lines containing a character (i.e. print only non-empty lines)</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/^.$/p&#39;</span> inputfile <span style="color:#75715e"># print only lines containing exactly one character</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/admin.*false/p&#39;</span> inputfile <span style="color:#75715e"># print only lines containing &#34;admin&#34; followed by &#34;false&#34; (with any number of arbitrary characters between them)</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/1[0,3]/p&#39;</span> inputfile <span style="color:#75715e"># print only lines containing a &#34;1&#34; followed by a &#34;0&#34; or &#34;3&#34;</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/1[0-2]/p&#39;</span> inputfile <span style="color:#75715e"># print only lines containing a &#34;1&#34; followed by a &#34;0&#34;, &#34;1&#34;, &#34;2&#34; or &#34;3&#34;</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/1.*2/p&#39;</span> inputfile <span style="color:#75715e"># print only lines containing the character &#34;1&#34; followed by a &#34;2&#34; (with any number of arbitrary characters between them)</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/1[0-9]*2/p&#39;</span> inputfile <span style="color:#75715e"># print only lines containing the character &#34;1&#34; followed by zero, one or more digits, followed by a &#34;2&#34;</span>
</span></span></code></pre></div><p>If you want to remove the special meaning of a character in a regular
expression (including the regex delimiter symbol), you have to precede
it with a slash:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Print all lines containing the string &#34;/usr/sbin/nologin&#34;</span>
</span></span><span style="display:flex;"><span>sed -ne <span style="color:#e6db74">&#39;/\/usr\/sbin\/nologin/p&#39;</span> inputfile
</span></span></code></pre></div><p>You are not limited to use only the slash as the regular expression
delimiter in an address. You can use any other character that could suit
your needs and tastes by preceding the first delimiter by a backslash.
This is particularly useful when you have addresses that should match
literal slashes like when working with file paths:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Both commands are perfectly identical</span>
</span></span><span style="display:flex;"><span>sed -ne <span style="color:#e6db74">&#39;/\/usr\/sbin\/nologin/p&#39;</span> inputfile
</span></span><span style="display:flex;"><span>sed -ne <span style="color:#e6db74">&#39;\=/usr/sbin/nologin=p&#39;</span> inputfile
</span></span></code></pre></div><p><a name="extended-regular-expressions"></a></p>
<h3 id="extended-regular-expressions">Extended regular expressions</h3>
<p>By default, the Sed regular expression engine only understands the
<a href="https://www.regular-expressions.info/posix.html#bre">POSIX basic regular
expression</a> syntax.
If you need <a href="https://www.regular-expressions.info/posix.html#ere">extended regular
expressions</a>, you
must add the <code>-E</code> flag to the Sed command. Extended regular expressions
add a couple of extra feature to basic regular expressions and, most
important maybe, they require far fewer backslashes. I let you compare:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/\(www\)\|\(mail\)/p&#39;</span> inputfile
</span></span><span style="display:flex;"><span>sed -En -e <span style="color:#e6db74">&#39;/(www)|(mail)/p&#39;</span> inputfile
</span></span></code></pre></div><p><a name="the-bracket-quantifier"></a></p>
<h3 id="the-bracket-quantifier">The bracket quantifier</h3>
<p>One powerful feature of regular expressions is the <a href="https://www.regular-expressions.info/repeat.html#limit">range
quantifier</a><code>{,}</code>.
Actually, when written exactly like that, this quantifier is a perfect
synonym for the <code>*</code> quantifier. However, you can explicitly add a lower
and upper bound on each side of the coma, something that gives a
tremendous amount of flexibility. When the lower bound of the range
quantifier is omitted, it is assumed to be zero. When the upper bound is
omitted, it is assumed to be the infinity:</p>
<p>Bracket notation   Shorthand   Description</p>
<hr>
<p>{,}                *          zero, one or many occurrences of the preceding regex
{,1}               ?           zero or one occurrence of the preceding regex
{1,}               +           one or many occurrences of the preceding regex
{n,n}              {n}         exactly n occurrences of the preceding regex</p>
<p>The bracket notation is available in basic regular expressions too, but
it requires backslashes. According to POSIX, the only quantifiers
available in basic regular expression are the star and the bracket
notation (with backslashes <code>\{m,n\}</code>). Many regex engines do support the
<code>\?</code> and <code>\+</code> notation as an extension. However, why tempting the devil?
If you need those quantifiers, using extended regular expressions will
be both easier to write and more portable.</p>
<p>If I took the time to talk about the bracket notation for regex
quantifiers, this is because that feature is often useful in Sed scripts
to count characters.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -En -e <span style="color:#e6db74">&#39;/^.{35}$/p&#39;</span> inputfile <span style="color:#75715e"># Print lines containing exactly 35 characters</span>
</span></span><span style="display:flex;"><span>sed -En -e <span style="color:#e6db74">&#39;/^.{0,35}$/p&#39;</span> inputfile <span style="color:#75715e"># Print lines containing 35 characters or less</span>
</span></span><span style="display:flex;"><span>sed -En -e <span style="color:#e6db74">&#39;/^.{,35}$/p&#39;</span> inputfile <span style="color:#75715e"># Print lines containing 35 characters or less</span>
</span></span><span style="display:flex;"><span>sed -En -e <span style="color:#e6db74">&#39;/^.{35,}$/p&#39;</span> inputfile <span style="color:#75715e"># Print lines containing 35 characters or more</span>
</span></span><span style="display:flex;"><span>sed -En -e <span style="color:#e6db74">&#39;/.{35}/p&#39;</span> inputfile <span style="color:#75715e"># I let you figure out this one by yourself (test it!)</span>
</span></span></code></pre></div><p><a name="range"></a></p>
<h3 id="range-addresses">Range addresses</h3>
<p>All the addresses we used so far were unique addresses. When using an
unique address, the command is applied only the line(s) matching that
address. However, Sed also supports range addresses. They are used to
apply a command to all lines <em>between</em> the start and the end address of
the range:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;1,5p&#39;</span> inputfile <span style="color:#75715e"># print only lines 1 through 5</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;5,$p&#39;</span> inputfile <span style="color:#75715e"># print from line 5 to the end of the file</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/home/217283.cloudwaysapps.com/wgnxdnqkza/public_html/,/systemd/p&#39;</span> inputfile <span style="color:#75715e"># print from the first line matching the /home/217283.cloudwaysapps.com/wgnxdnqkza/public_html/ regular expression to the next line matching the /systemd/ regular expression.</span>
</span></span></code></pre></div><p>If the same line <em>number</em> is used both for the start and end address,
the range is reduced to that line. Actually, if the second address is a
number less than or equal to the line number of the first selected line
of the range, only one line will be selected:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>printf <span style="color:#e6db74">&#34;%s\n&#34;</span> <span style="color:#f92672">{</span>a,b,c<span style="color:#f92672">}{</span>d,e,f<span style="color:#f92672">}</span> | cat -n | sed -ne <span style="color:#e6db74">&#39;4,4p&#39;</span>
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">4</span>    bd
</span></span><span style="display:flex;"><span>printf <span style="color:#e6db74">&#34;%s\n&#34;</span> <span style="color:#f92672">{</span>a,b,c<span style="color:#f92672">}{</span>d,e,f<span style="color:#f92672">}</span> | cat -n | sed -ne <span style="color:#e6db74">&#39;4,3p&#39;</span>
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">4</span>    bd
</span></span></code></pre></div><p>This is somewhat tricky, but the rule given in the previous paragraph
also applies when the <em>start address is a regular expression</em>. In that
case, Sed will compare the <em>line number</em> of the first line matching the
regex with the explicit <em>line number</em> given as end address. Once again,
if the end line number is lower or equal to the start line number, the
range will be reduced to one line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># The /b/,4 address will match *three* one-line range</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># since each matching line has a line number &gt;= 4</span>
</span></span><span style="display:flex;"><span>printf <span style="color:#e6db74">&#34;%s\n&#34;</span> <span style="color:#f92672">{</span>a,b,c<span style="color:#f92672">}{</span>d,e,f<span style="color:#f92672">}</span> | cat -n | sed -ne <span style="color:#e6db74">&#39;/b/,4p&#39;</span>
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">4</span>  bd
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">5</span>  be
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">6</span>  bf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># I let you figure by yourself how many ranges are matched</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># by that second example:</span>
</span></span><span style="display:flex;"><span>printf <span style="color:#e6db74">&#34;%s\n&#34;</span> <span style="color:#f92672">{</span>a,b,c<span style="color:#f92672">}{</span>d,e,f<span style="color:#f92672">}</span> | cat -n | sed -ne <span style="color:#e6db74">&#39;/d/,4p&#39;</span>
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">1</span>  ad
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">2</span>  ae
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">3</span>  af
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">4</span>  bd
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">7</span>  cd
</span></span></code></pre></div><p>However, the behavior of Sed is different when the end address is a
<em>regular expression</em>. In that case, the first line of the range is <em>not</em>
tested against the end address, so the range will contain at least two
lines (except of course if there is not enough input data):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>printf <span style="color:#e6db74">&#34;%s\n&#34;</span> <span style="color:#f92672">{</span>a,b,c<span style="color:#f92672">}{</span>d,e,f<span style="color:#f92672">}</span> | cat -n | sed -ne <span style="color:#e6db74">&#39;/b/,/d/p&#39;</span>
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">4</span>    bd
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">5</span>    be
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">6</span>    bf
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">7</span>    cd
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>printf <span style="color:#e6db74">&#34;%s\n&#34;</span> <span style="color:#f92672">{</span>a,b,c<span style="color:#f92672">}{</span>d,e,f<span style="color:#f92672">}</span> | cat -n | sed -ne <span style="color:#e6db74">&#39;4,/d/p&#39;</span>
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">4</span>    bd
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">5</span>    be
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">6</span>    bf
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">7</span>    cd
</span></span></code></pre></div><h3 id="a-namecomplementcomplementa"><a name="complement">Complement</a></h3>
<p>Adding an exclamation mark (<code>!</code>) after an address select lines <em>not</em>
matching that address. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;5!p&#39;</span> inputfile <span style="color:#75715e"># Print all lines except line 5</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;5,10!p&#39;</span> inputfile <span style="color:#75715e"># Print all lines except line 5 to 10</span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/sys/!p&#39;</span> inputfile <span style="color:#75715e"># Print all lines except those containing &#34;sys&#34;</span>
</span></span></code></pre></div><p><a name="conjunctions"></a></p>
<h3 id="conjunctions">Conjunctions</h3>
<p>Sed allows to group commands in blocks using brackets (<code>{…​}</code>). You can
leverage that feature to combine several addresses. For example, let’s
compare the output of those two commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/usb/{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/daemon/p
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}&#39;</span> inputfile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;/usb.*daemon/p&#39;</span> inputfile
</span></span></code></pre></div><p>By nesting commands in a block, we will select lines containing “usb”
and “daemon” in any order. Whereas the regular expression “usb.*daemon”
would only match lines where the “usb” string appears before the
“daemon” string.</p>
<p>After that long digression, let’s go back now to our review of the
various Sed commands.</p>
<h2 id="the-quit-command"><a name="the-quit-command"></a>
The quit command</h2>
<p>The quit command will stop Sed at the end of the current processing loop
iteration.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-quit-command.png" alt="The Sed \`quit\`command"></p>
<p>The <code>quit</code> command is a way to stop input processing before reaching the
end of the input file. Why would someone want to do that?</p>
<p>Well, if you remember, we’ve seen you can print the lines 1 through 5 of
a file using the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;1,5p&#39;</span> inputfile
</span></span></code></pre></div><p>With most implementations of Sed, the tool will read and cycle over all
the remaining input lines, even if only the first five can produce a
result. This may have a significant impact if your file contains
millions of rows (or even worst, if you read from an infinite stream of
data like <code>/dev/urandom</code> for example).</p>
<p>Using the quit command, the same program can be rewritten much more
efficiently:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -e <span style="color:#e6db74">&#39;5q&#39;</span> inputfile
</span></span></code></pre></div><p>Here, since I did not use the <code>-n</code> option, Sed will implicitly print the
pattern space at the end of each cycle, but it will quit, and thus not
reading more data, after having processed the line 5.</p>
<p>We could use a similar trick to print only a specific line of a file.
That will be a good occasion to see several ways of providing multiple
Sed expressions from the command line. The three variations bellow take
benefit of Sed accepting several commands, either as different <code>-e</code>
options, or in the same expression, but separated by newlines or
semi-colon:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;5p&#39;</span> -e <span style="color:#e6db74">&#39;5q&#39;</span> inputfile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  5p
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  5q
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span> inputfile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sed -n -e <span style="color:#e6db74">&#39;5p;5q&#39;</span> inputfile
</span></span></code></pre></div><p>If you remember it, we’ve seen earlier we can group commands using
brackets, something that we could use here to avoid repeating the same
address twice:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># By grouping commands</span>
</span></span><span style="display:flex;"><span>sed -e <span style="color:#e6db74">&#39;5{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  p
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  q
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}&#39;</span> inputfile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Which can be shortened as:</span>
</span></span><span style="display:flex;"><span>sed <span style="color:#e6db74">&#39;5{p;q;}&#39;</span> inputfile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># As a POSIX extension, some implementations makes the semi-colon before the closing bracket optional:</span>
</span></span><span style="display:flex;"><span>sed <span style="color:#e6db74">&#39;5{p;q}&#39;</span> inputfile
</span></span></code></pre></div><h2 id="the-substitution-command"><a name="substitution"></a>
The substitution command</h2>
<p>You can imagine the substitution command as the Sed equivalent to the
search-replace feature you can find on most WYSIWYG editors. An
equivalent, albeit a more powerful one though. The substitution command
being one of the best-known Sed commands, it is largely documented on
the web.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-substitution-command.png" alt="The Sed \`substitution\`command"></p>
<p>We already have covered it <a href="http://linuxhandbook.com/?p=128">in a previous
article</a> so I will not repeat myself
here. However there are some key points to remember if you’re not yet
completely familiar with it:</p>
<ul>
<li>
<p>The substitution command takes two parameters: the search pattern
and the replacement string: <code>sed s/:/-----/ inputfile</code></p>
</li>
<li>
<p>The command and its arguments are separated by an arbitrary
character. Mostly by habit, 99% of the time we use a slash but any
other character can be used: <code>sed s%:%-----% inputfile</code>,
<code>sed sX:X-----X inputfile</code> or even <code>sed 's : ----- ' inputfile</code></p>
</li>
<li>
<p>By default, the substitution is applied only to the first matching
substring of the pattern space. You can change that by specifying
the match index as a flag after the command:
<code>sed 's/:/-----/1' inputfile</code>, <code>sed 's/:/-----/2' inputfile</code>,
<code>sed 's/:/-----/3' inputfile</code>, …</p>
</li>
<li>
<p>If you want to perform a substitution globally (i.e.: on each
non-overlapping match of the pattern space), you need to add the <code>g</code>
flag: <code>sed 's/:/-----/g' inputfile</code></p>
</li>
<li>
<p>In the replacement string, any occurrence of the ampersand (<code>&amp;</code>)
will be replaced by the substring matching the search pattern:
<code>sed 's/:/-&amp;&amp;&amp;-/g' inputfile</code>, <code>sed 's/…​./&amp; /g' inputfile</code></p>
</li>
<li>
<p>Parenthesis ( <code>(…​)</code> in extended regex or <code>\(…​\)</code> in basic regex)
introduce a <em>capturing group</em>. That is a part of the matching string
that can be referenced in the replacement string. <code>\1</code> is the
content of the first capturing group, <code>\2</code> the content of the second
one and so on: <code>sed -E 's/(.)(.)/\2\1/g' inputfile</code>,
<code>sed -E 's/(.)❌(.):(.*)/\1:\3/' inputfile</code> (that latter works
because <a href="https://www.regular-expressions.info/repeat.html#greedy">the star regular expression quantifier is
greedy</a>,
and matches as many characters as it can)</p>
</li>
<li>
<p>In the search pattern or the replacement string you can remove the
special meaning of any character by preceding it with a backslash:
<code>sed 's/:/--\&amp;--/g' inputfile</code>, <code>sed 's/\//\\/g' inputfile</code></p>
</li>
</ul>
<p>As all this might seem a little bit abstract, here are a couple of
examples. To start, let’s say I want to display the first field of my
test input file padded with spaces on the right up to 20 characters, I
could write something like that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed &lt; inputfile -E -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/:/                    / # replace the first field separator by 20 spaces
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/(.{20}).*/\1/           # keep only the first 20 characters of the line
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/.*/| &amp; |/               # add vertical bars for a nice output
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>As a second example, if I want to change the UID/GID of the user sonia
to 1100, I could write something like that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -En -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  /sonia/{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    s/[0-9]+/1100/g
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  }&#39;</span> inputfile
</span></span></code></pre></div><p>Notice the <code>g</code> option at the end of the substitution command. It
modifies its behavior, so all occurrences of the search pattern are
replaced. Without that option, only the first one would be.</p>
<p>By the way, this is also a good occasion to mention the print command
displays the content of the pattern space at the moment the command is
executed. So, I can obtain a before-after output like that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -En -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  /sonia/{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    s/[0-9]+/1100/g
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  }&#39;</span> inputfile
</span></span></code></pre></div><p>Actually, since printing a line after a substitution is a common use
case, the substitution command also accepts the <code>p</code> option for that
purpose:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -En -e <span style="color:#e6db74">&#39;/sonia/s/[0-9]+/1100/gp&#39;</span> inputfile
</span></span></code></pre></div><p>Finally, I won’t be exhaustive without mentioning the <code>w</code> option of the
substitution command. We will examine it in detail <a href="#write-flag">later</a>.</p>
<p><a name="the-delete-command"></a></p>
<h3 id="the-delete-command">The delete command</h3>
<p>The delete command (<code>d</code>) is used to clear the pattern space and
immediately start the next cycle. By doing so, it will also skip the
implicit print of the pattern space even if the auto-print flag is set.</p>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-delete-command.png" alt="The Sed \`delete\`command"></p>
<p>A particularly inefficient way of printing only the first five lines of
a file would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -e <span style="color:#e6db74">&#39;6,$d&#39;</span> inputfile
</span></span></code></pre></div><p>I let you guess why I said this was inefficient. If this is not obvious,
try to re-read the section concerning the <a href="#quit">quit command</a>. The
answer is there!</p>
<p>The delete command is particularly useful when combined with regular
expression-based addresses to remove matching lines from the output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed -e <span style="color:#e6db74">&#39;/systemd/d&#39;</span> inputfile
</span></span></code></pre></div><p><a name="the-next-command"></a></p>
<h3 id="the-next-command">The next command</h3>
<p>This command prints the current pattern space if Sed is not running in
quiet mode, then, in all cases, it reads the next input line into the
pattern space and executes the <em>remaining commands of the current cycle</em>
with the new pattern space.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-next-command.png" alt="The Sed \`next\`command"></p>
<p>A common use case of the next command is to skip lines:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -n -e <span style="color:#e6db74">&#39;n;n;p&#39;</span>
</span></span></code></pre></div><p>In the example above, Sed will implicitly read the first line of the
input file. But the <code>next</code> command discards (and does not display
because of the <code>-n</code> option) the pattern space and replaces it with the
next line from the input. And the second <code>next</code> command will do the same
thing, skipping now the line 2 of the input. And finally, the script
explicitly prints the pattern space which now contains the third line of
the input. Then Sed will start a new cycle, implicitly reading the line
4, then skipping it, as well as the line 5, because of the <code>next</code>
commands, and it will print the line 6. And again and again until the
end of the file. Concretely, this prints one line over three of the
input file.</p>
<p>Using the next command, we can also find a couple of other ways to
display the first five lines of a file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -n -e <span style="color:#e6db74">&#39;1{p;n;p;n;p;n;p;n;p}&#39;</span>
</span></span><span style="display:flex;"><span>cat -n inputfile | sed -n -e <span style="color:#e6db74">&#39;p;n;p;n;p;n;p;n;p;q&#39;</span>
</span></span><span style="display:flex;"><span>cat -n inputfile | sed -e <span style="color:#e6db74">&#39;n;n;n;n;q&#39;</span>
</span></span></code></pre></div><p>More interestingly, the next command is also very useful when you want
to process lines <em>relative</em> to some address:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -n <span style="color:#e6db74">&#39;/pulse/p&#39;</span>       <span style="color:#75715e"># print lines containing &#34;pulse&#34;</span>
</span></span><span style="display:flex;"><span>cat -n inputfile | sed -n <span style="color:#e6db74">&#39;/pulse/{n;p}&#39;</span>   <span style="color:#75715e"># print the line following</span>
</span></span><span style="display:flex;"><span>                                           <span style="color:#75715e"># the line containing &#34;pulse&#34;</span>
</span></span><span style="display:flex;"><span>cat -n inputfile | sed -n <span style="color:#e6db74">&#39;/pulse/{n;n;p}&#39;</span> <span style="color:#75715e"># print the line following</span>
</span></span><span style="display:flex;"><span>                                           <span style="color:#75715e"># the line following</span>
</span></span><span style="display:flex;"><span>                                           <span style="color:#75715e"># the line containing &#34;pulse&#34;</span>
</span></span></code></pre></div><h2 id="working-with-the-hold-space"><a name="working-with-the-hold-space"></a>
Working with the hold space</h2>
<p>Until now, the command we’ve seen dealt only with the pattern space.
However, as we’ve mentioned it at the very top of this article, there is
a second buffer, the hold space, entirely under the control of the user.
This will be the purpose of the commands described in this section.</p>
<p><a name="exchange"></a></p>
<h3 id="the-exchange-command">The exchange command</h3>
<p>As it names implies it, the exchange command (<code>x</code>) will swap the content
of the hold and pattern space. Remember as long as you didn’t put
anything into the hold space, it is empty.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-exchange-command.png" alt="The Sed \`exchange\`command"></p>
<p>As a first example, we may use the exchange command to print in reverse
order the first two lines of a file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -n -e <span style="color:#e6db74">&#39;x;n;p;x;p;q&#39;</span>
</span></span></code></pre></div><p>Of course, you don’t have to use the content of the hold space
immediately after having set it, since the hold space remains untouched
as long as you don’t explicitly modify it. In the following example, I
use it to move the first line of the input after the fifth one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -n -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  1{x;n}                # Swap the hold and pattern space
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # to store line 1 into the hold buffer
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # and then read line two
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  5{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p                   # print line 5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    x                   # swap the hold and pattern space to get
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # back the content of line one into the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # pattern space
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  1,5p                  # triggered on lines 2 through 5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # (not a typo! try to figure why this rule
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # is NOT executed for line 1;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p><a name="hold"></a></p>
<h3 id="the-hold-commands">The hold commands</h3>
<p>The hold command (<code>h</code>) is used to store the content of the pattern space
into the hold space. However, as opposed to the exchange command, this
time the content of the pattern space is left unchanged. The hold
commands came in two flavors:</p>
<dl>
<dt><code>h</code></dt>
<dd>
<p>that will copy the content of the pattern space into the hold space,
overwriting any value already present</p>
</dd>
<dt><code>H</code></dt>
<dd>
<p>that will append the content of the pattern space to the hold space,
using a newline as separator</p>
</dd>
</dl>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-hold-command.png" alt="The Sed \`hold\`command"></p>
<p>The example above using the exchange command can be rewritten using the
hold command instead:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -n -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  1{h;n}                # Store line 1 into the hold buffer and continue
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  5{                    # on line 5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    x                   # switch the pattern and hold space
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # (now the pattern space contains the line 1)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    H                   # append the line 1 after the line 5 in the hold space
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    x                   # switch again to get back lines 5 and 1 into
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # the pattern space
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  1,5p                  # triggered on lines 2 through 5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # (not a typo! try to figure why this rule
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # is NOT executed for line 1;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p><a name="get"></a></p>
<h3 id="the-get-command">The get command</h3>
<p>The get command (<code>g</code>) does the exact opposite of the hold command: it
takes the content of the hold space and put it into the pattern space.
Here again, it comes in two flavors:</p>
<dl>
<dt><code>g</code></dt>
<dd>
<p>that will copy the content of the hold space into the pattern space,
overwriting any value already present</p>
</dd>
<dt><code>G</code></dt>
<dd>
<p>that will append the content of the hold space to the pattern space,
using a newline as separator</p>
</dd>
</dl>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-get-command.png" alt="The Sed \`get\`command"></p>
<p>Together, the hold and get commands allow to store and recall data. As a
little challenge, I let you rewrite the example of the previous section
to put the line 1 of the input file after the line 5, but this time
using the get and hold commands (lower- or upper-case version), but
<em>without</em> using the exchange command. With a little bit of luck, it
should be simpler that way!</p>
<p>In the meantime, I can show you another example that could serve for
your inspiration. The goal here is to separate the users having a login
shell from the others:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -En -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  \=(/usr/sbin/nologin|/bin/false)$= { H;d; }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              # Append matching lines to the hold buffer
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              # and continue to next cycle
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  p           # Print other lines
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  $ { g;p }   # On the last line,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              # get and print the content of the hold buffer
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><h2 id="print-delete-and-next-revisited"><a name="print-delete-and-next-revisited"></a>
print, delete and next revisited</h2>
<p>Now you’ve gained more familiarities with the hold space, let me go back
on the <code>print</code>, <code>delete</code> and <code>next</code> commands. We already talked about
the lower case <code>p</code>, <code>d</code> and <code>n</code> commands. But they also have an upper
case version. As it seems to be a convention with Sed, the uppercase
version of those commands will be related to multi-line buffers:</p>
<dl>
<dt><code>P</code></dt>
<dd>
<p>print the content of the pattern space <em>up to the first newline</em></p>
</dd>
<dt><code>D</code></dt>
<dd>
<p>delete the content of the pattern space <em>up and including the first
newline</em> then restart a cycle with the remaining text <em>without</em>
reading any new input</p>
</dd>
<dt><code>N</code></dt>
<dd>
<p><em>read and append a new line of input</em> to the pattern space using the
newline character as a separator between the old and new data.
Continue the execution of the current cycle.</p>
</dd>
</dl>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-delete-upper-command.png" alt="The Sed uppercase \`Delete\`command"></p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-next-upper-command.png" alt="The Sed uppercase \`Next\`command"></p>
<p>The main use case for those commands is to implement queues (<a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">FIFO
lists</a>).
The canonical example being removing the last 5 lines from a file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -En -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  1 { N;N;N;N }     # ensure the pattern space contains *five* lines
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  N                 # append a sixth line onto the queue
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  P                 # Print the head of the queue
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  D                 # Remove the head of the queue
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>As a second example, we could display input data on two columns:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Print on two columns</span>
</span></span><span style="display:flex;"><span>sed &lt; inputfile -En -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> $!N                # Append a new line to the pattern space
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    # *except* on the last line of input
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    # This is a trick required to deal with
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    # inconsistencies between GNU Sed and POSIX Sed
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    # when using N on the last line of input
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    # https://www.gnu.org/software/sed/manual/sed.html#N_005fcommand_005flast_005fline
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    # Right pad the first field of the first line
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    # with spaces and discard rest of the line
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> s/:.*\n/                    \n/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> s/:.*//            # Discard all but the first field on the second line
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> s/(.{20}).*\n/\1/  # Trim and join lines
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> p                  # Print result
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><h2 id="branching"><a name="branches"></a>
Branching</h2>
<p>We just saw Sed has buffer capabilities through the hold space. But it
also has test and branch instructions. Having both those features makes
Sed a <a href="https://chortle.ccsu.edu/StructuredC/Chap01/struct01_5.html">Turing
complete</a>
language. It may sound silly, but that means you can write any program
using Sed. You can do it, but that does not mean it would be an easy
task, nor that the result would be particularly efficient of course.</p>
<p>However, don’t panic. In this article, we will stay with simple examples
of tests and branches. Even if these capabilities seem limited at first
sight, remember some people have written
[calculators],
[Tetris] or many other
kinds of applications using sed!</p>
<p><a name="labels-and-branches"></a></p>
<h3 id="labels-and-branches">labels and branches</h3>
<p>By some aspects, you can see Sed as a very limited assembly language. So
you won’t find high-level “for” or “while” loops or “if … else”
statements, but you can implement them using branches.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-branch-command.png" alt="The Sed \`branch\`command"></p>
<p>If you take a look at the flowchart describing the Sed execution model
at the top of this article, you can see Sed automatically increments the
program counter, resulting in the execution of the commands in the
program’s instructions order. However, using branch instructions, you
can break that sequential flow by continuing the execution with any
command of your choice in the program. The destination of a jump is
explicitly defined using a label.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-label-command.png" alt="The Sed \`label\`command"></p>
<p>Here is an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>echo hello | sed -ne <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  :start      # Put the &#34;start&#34; label on that line of the program
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  p           # Print the pattern buffer
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  b start     # Continue execution at the :start label
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span> | less
</span></span></code></pre></div><p>The behavior of that Sed program is very close to the <code>yes</code> command: it
takes a string and produces an infinite stream of lines containing that
string.</p>
<p>Branching to a label as we did bypass all Sed automatic features: it
does not read any input, nor print anything, nor update any buffer. It
just jumps to a different instruction instead of executing the next one
in the source program order.</p>
<p>Worth mentioning without any label specified as an argument, the branch
command (<code>b</code>) will branch to the end of the program. So Sed will start a
new cycle. This may be useful to bypass some instructions and thus may
be used as an alternative to blocks:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -ne <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/usb/!b
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/daemon/!b
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">p
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p><a name="conditional-branch"></a></p>
<h3 id="conditional-branch">Conditional branch</h3>
<p>Until now, we’ve seen the so-called unconditional branches, even if the
term is somewhat misleading in this context since Sed commands are
always conditional based on their optional address.</p>
<p>However, in a more traditional sense, an <em>unconditional</em> branch is a
branch that, when executed, will <em>always jump</em> to the specified
destination, whereas a <em>conditional</em> branch <em>may or may not jump</em> to the
specified instruction depending on the current state of the system.</p>
<p>Sed has only one conditional instruction, the test (<code>t</code>) command. It
jumps to a different instruction only if a substitution was executed
since the start of the current cycle or since the previous conditional
branch. More formally, the test command will branch only if the
<em>substitution flag</em> is set.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-test-command.png" alt="The Sed \`test\`command"></p>
<p>With the test instruction, you can easily perform loops in a Sed
program. As a practical example, you can use that to pad lines to a
certain length (something you can’t do with regex only):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Center text</span>
</span></span><span style="display:flex;"><span>cut -d: -f1 inputfile | sed -Ee <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  :start
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/^(.{,19})$/ \1 /    # Pad lines shorter than 20 chars with
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # a space at the start and another one
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # at the end
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  t start               # Go back to :start if we added a space
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/(.{20}).*/| \1 |/   # Keep only the first 20 char of the line
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # to fix the off-by-one error caused by
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # odd lines
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>If you carefully read the previous example, you’ve noticed I cheated a
little bit by using the cut command to pre-process the data before
feeding them to sed.</p>
<p>We can, however, perform the same task using only sed at the cost of a
small modification to the program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat inputfile | sed -Ee <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/:.*//               # Remove all but the first field
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  t start
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  :start
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/^(.{,19})$/ \1 /    # Pad lines shorter than 20 chars with
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # a space at the start and another one
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # at the end
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  t start               # Go back to :start if we added a space
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/(.{20}).*/| \1 |/   # Keep only the first 20 char of the line
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # to fix the off-by-one error caused by
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        # odd lines
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>In the above example, you may be surprised by the following construct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>t start
</span></span><span style="display:flex;"><span>:start
</span></span></code></pre></div><p>At first sight, the branch here seems useless since it will jump to the
instruction that would have been executed anyway. However, if you read
the definition of the <code>test</code> command attentively, you will see it
branches only <em>if there was a substitution</em> since the start of the
current cycle or <em>since the previous test command was executed</em>. In
other words, the test instruction has the side effect of clearing the
<em>substitution flag</em>. This is exactly the purpose of the code fragment
above. This is a trick you will often see in Sed programs containing
conditional branches to avoid false positive when using several
substitutions commands.</p>
<p>I agree though it wasn’t absolutely mandatory here to clear the
substitution flag since the specific substitution command I used is
idempotent once it has padded the string to the right length. So one
extra iteration will not change the result. However, look at that second
example now:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Classify user accounts based on their login program</span>
</span></span><span style="display:flex;"><span>cat inputfile | sed -Ene <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/^/login=/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  /nologin/s/^/type=SERV /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  /false/s/^/type=SERV /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  t print
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/^/type=USER /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  :print
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/:.*//p
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>My hope here was to tag the user accounts with either “SERV” or “USER”
depending on the configured default login program. If you ran it, you’ve
seen the “SERV” tag as expected. However, no trace of the “USER” tag in
the output. Why? Because the <code>t print</code> instruction will <em>always</em> branch
since whatever was the content of the line, the <em>substitution flag</em> was
set by the very first substitution command of the program. Once set, the
flag remains set until a next line is read— or until the next test
command. And gives us the solution to fix that program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Classify user accounts based on the login program</span>
</span></span><span style="display:flex;"><span>cat inputfile | sed -Ene <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/^/login=/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  t classify # clear the &#34;substitution flag&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  :classify
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  /nologin/s/^/type=SERV /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  /false/s/^/type=SERV /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  t print
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/^/type=USER /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  :print
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/:.*//p
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><h2 id="handling-verbatim-text"><a name="handling-verbatim-text"></a>
Handling verbatim text</h2>
<p>Sed is a text editor. A non-interactive one. But a text editor
nevertheless. It wouldn’t be complete without some facility to insert
literal text in the output. I’m not a big fan of that feature since I
find the syntax awkward (even by the Sed standards), but sometimes you
can’t avoid it.</p>
<p>In the strict POSIX syntax, all the three commands to change (<code>c</code>),
insert (<code>i</code>) or append (<code>a</code>) some literal text to the output follow the
same specific syntax: the command letter is followed by a backslash, and
the text to insert start on the next line of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>head -5 inputfile | sed <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">1i\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># List of user accounts
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">$a\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># end
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>To insert multiple lines of text, you must end each of them with a
backslash:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>head -5 inputfile | sed <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">1i\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># List of user accounts\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># (users 1 through 5)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">$a\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># end
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>Some Sed implementations, like GNU Sed, makes the newline after the
initial backslash optional, even when forced in <code>--posix</code> mode. I didn’t
find anything in the standard that authorizes that alternate syntax. So
use it at your own risks if portability is a premium (or leave a comment
if I missed that feature in the specifications!):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># non-POSIX syntax:</span>
</span></span><span style="display:flex;"><span>head -5 inputfile | sed -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">1i \# List of user accounts
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">$a\# end
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>Some Sed implementation also makes the initial backslash completely
optional. Since this is, without any doubt this time, a vendor-specific
extension to the POSIX specifications, I let you check the manual for
the version of sed you use to check if it supports that syntax.</p>
<p>After that quick overview, let’s review those commands in more details
now, starting with the change command I didn’t have presented yet.</p>
<p><a name="the-change-command"></a></p>
<h3 id="the-change-command">The change command</h3>
<p>The change command (<code>c\</code>) deletes the pattern space and starts a new
cycle just like the <code>d</code> command. The only difference is the user
provided text is written on the output when the command is executed.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-change-command.png" alt="The Sed \`change\`command"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/systemd/c\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># :REMOVED:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">s/:.*// # This will NOT be applied to the &#34;changed&#34; text
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>If the change command is associated with a <a href="#range">range address</a>, the
text is output only once, when reaching the last line of the range.
Which somehow makes it an exception to the convention a Sed command is
repeatedly applied to all lines of its range address:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">19,22c\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># :REMOVED:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">s/:.*// # This will NOT be applied to the &#34;changed&#34; text
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>As a consequence, if you want the change command to be repeated for
every line in a range, you have no other choice than wrapping it inside
a block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>cat -n inputfile | sed -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">19,22{c\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># :REMOVED:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">s/:.*// # This will NOT be applied to the &#34;changed&#34; text
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p><a name="the-insert-command"></a></p>
<h3 id="the-insert-command">The insert command</h3>
<p>The insert command (<code>i\</code>) immediately print the user-provided text on
the output. It does not alter in any way the program flow or buffer
content.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-insert-command.png" alt="The Sed \`insert\`command"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># display the first five user names with a title on the first row</span>
</span></span><span style="display:flex;"><span>sed &lt; inputfile -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">1i\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">USER NAME
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">s/:.*//
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">5q
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p><a name="the-append-command"></a></p>
<h3 id="the-append-command">The append command</h3>
<p>The append command (<code>a\</code>) queues some text to be displayed when the next
line of input will be read. The text is output at the end of the current
cycle (including at the end of the program) or when a new line is read
from the input using either the <code>n</code> or <code>N</code> command.</p>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-append-command.png" alt="The Sed \`append\`command"></p>
<p>Same example as above, but inserts this time a footer instead of a
header:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed &lt; inputfile -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">5a\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">USER NAME
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">s/:.*//
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">5q
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p><a name="read"></a></p>
<h3 id="the-read-command">The read command</h3>
<p>There is a fourth command to insert literal content into the output
stream: the read command (<code>r</code>). It works exactly like the append
command, but instead of taking the text hardcoded from the Sed script
itself, it will write the content of a file on the output.</p>
<p>The read command only schedules the file to be read. That latter is
effectively read when the append queue is flushed. Not when the read
command is executed. This may have implications if there are concurrent
accesses to the file to be read, if that file is not a regular file (for
example, if it’s a character device or a named pipe), or if the file is
modified during processing.</p>
<p>As an illustration, if you use the <a href="#write">write</a> command we will see
in detail in the next section together with the read command to write
and re-read from a temporary file, you may obtain some creative results
(using a French equivalent of the
<a href="https://en.wikipedia.org/wiki/Shiritori">Shiritori</a> game as an
illustration):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>printf <span style="color:#e6db74">&#34;%s\n&#34;</span> <span style="color:#e6db74">&#34;Trois p&#39;tits chats&#34;</span> <span style="color:#e6db74">&#34;Chapeau d&#39; paille&#34;</span> <span style="color:#e6db74">&#34;Paillasson&#34;</span> |
</span></span><span style="display:flex;"><span>sed -ne <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  r temp
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  a\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  ----
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  w temp
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>We’ve now ended the list of the Sed commands dedicated to the insertion
of literal text in the stream output. My last example was mostly for
fun, but since I mentioned there the write command, that makes a perfect
transition with the next section where we will see how to write data to
an external file from Sed.</p>
<h2 id="alternate-output"><a name="alternate-output"></a>
Alternate output</h2>
<p>Sed is designed with the idea all text transformations will end-up being
written on the standard output of the process. However, Sed also has
some provision to send data to alternate destinations. You have two ways
to do that: using the dedicated write command, or by adding the write
flag to a substitution command.</p>
<p><a name="write"></a></p>
<h3 id="the-write-command">The write command</h3>
<p>The write command (<code>w</code>) appends the content of the pattern space to the
given destination file. POSIX requires the destination file to be
created by Sed before it starts processing any input data. If the file
already exists, it is overwritten.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-write-command.png" alt="The Sed \`write\`command"></p>
<p>As a consequence, even if you never really write to a file, it will be
created anyway. For example, the following Sed program will
create/overwrite the “output” file, even if the write command is never
executed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>echo | sed -ne <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">q         # immediately quit
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">w output  # this command is never executed
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>You can have several write commands referencing the same destination
file. All write commands at the destination of the same file will append
content to that file (more or less in the same manner as the <code>&gt;&gt;</code> shell
redirection). :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed &lt; inputfile -ne <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/:\/bin\/false$/w server
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/:\/usr\/sbin\/nologin$/w server
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">w output
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>cat server
</span></span></code></pre></div><p><a name="write-flag"></a></p>
<h3 id="the-substitution-command-write-flag">The substitution command <code>write</code> flag</h3>
<p>A long time ago now, we had seen the substitution command has the <code>p</code>
option for the common use case of printing the pattern space after a
substitution. In a very similar manner it also has a <code>w</code> option to write
the pattern space to a file after a substitution:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sed &lt; inputfile -ne <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">s/:.*\/nologin$//w server
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">s/:.*\/false$//w server
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>cat server
</span></span></code></pre></div><h2 id="comments"><a name="comment"></a>
Comments</h2>
<p>I already used them countless times, but I never took the time to
introduce them formally, so, let’s fix that: like in most programming
languages, a <em>comment</em> is a way to add free-form text the software will
not try to interpret. The Sed syntax being rather cryptic, I can’t
insist enough on the need to comment your scripts. Otherwise, they will
be hardly understandable by anyone except their author.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-comment-command.png" alt="The Sed \`comment\`command"></p>
<p>However, like many other parts of Sed, comments have their own share of
subtleties. First, and the most important, comments are not a syntactic
construct, but are full-fledged commands in Sed. A do-nothing (“no-op”)
command, but a command anyway. At least, that is how there are defined
by POSIX. So, strictly speaking, they should only be allowed where other
commands are allowed.</p>
<p>Most Sed implementation relaxes that requirement by allowing inline
commands as I used them all over the place in that article.</p>
<p>To close on that topic, worth mentioning the very special case of the
<code>#n</code> comment (an octothorpe followed by the letter n without any space).
If that exact comment if found on the very first line of a script, Sed
should switch to quiet mode (i.e., clearing the auto-print flag) just
like if the <code>-n</code> option was specified on the command line.</p>
<h2 id="the-commands-you-will-rarely-need"><a name="the-commands-you-will-rarely-need"></a>
The commands you will rarely need</h2>
<p>Now, we have reviewed the commands that will allow you to write 99.99%
of your scripts. But this tour wouldn’t be exhaustive if I didn’t
mention the last remaining Sed commands. I left them aside until now
because I rarely needed them. But maybe did you have on your side
examples of practical use cases where you find them useful. If that is
the case do not hesitate to share that with us using the comment
section.</p>
<p><a name="the-line-number-command"></a></p>
<h3 id="the-line-number-command">The line number command</h3>
<p>The <code>=</code> command writes on the standard output the number of lines
currently read by Sed, that is the content of the line counter register.
There is no way to capture that number in one of the Sed buffers, nor to
format the output. Two limitations that severely reduce the usefulness
of that command.</p>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-current-line-command.png" alt="The Sed \`line number\`command"></p>
<p>Remember in strict POSIX compliance mode, when several input files are
given on the command line, Sed does not reset that counter but continue
to increment it just like if all the files where concatenated. Some Sed
implementations like GNU Sed have options to reset the counter after
each input file.</p>
<p><a name="the-unambiguous-print-command"></a></p>
<h3 id="the-unambiguous-print-command">The unambiguous print command</h3>
<p>The <code>l</code> (lowercase letter ell) is similar to the print command (<code>p</code>),
but the content of the pattern space will be written in an unambiguous
form. To quote <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html">the POSIX
standard</a>:</p>
<blockquote>
<p>The characters listed in XBD Escape Sequences and Associated Actions (
‘\\’, ‘\a’, ‘\b’, ‘\f’, ‘\r’, ‘\t’, ‘\v’ ) shall be written as
the corresponding escape sequence; the ‘\n’ in that table is not
applicable. Non-printable characters not in that table shall be
written as one three-digit octal number (with a preceding
&lt;backslash&gt;) for each byte in the character (most significant
byte first). Long lines shall be folded, with the point of folding
indicated by writing a &lt;backslash&gt; followed by a
&lt;newline&gt;; the length at which folding occurs is unspecified,
but should be appropriate for the output device. The end of each line
shall be marked with a ‘$’.</p>
</blockquote>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-unambiguous-print-command.png" alt="The Sed \`unambiguous print\`command"></p>
<p>I suspect this command was once used to exchange data over non <a href="https://en.wikipedia.org/wiki/8-bit_clean">8-bits
clean channels</a>. As of
myself, I never used it for anything else than for debugging purposes.</p>
<p><a name="the-transliterate-command"></a></p>
<h3 id="the-transliterate-command">The transliterate command</h3>
<p>The transliterate (<code>y</code>) command allows mapping characters of the pattern
space from a source set to a destination set. It is quite similar to the
<code>tr</code> command, although more limited.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-transliterate-command.png" alt="The Sed \`transliterate\`command"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># The `y` c0mm4nd 1s for h4x0rz only</span>
</span></span><span style="display:flex;"><span>sed &lt; inputfile -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/:.*//
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  y/abcegio/48&lt;3610/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>While the transliterate command syntax bears some resemblances with the
substitution command syntax, it does not accept any option after the
replacement string. The transliteration is always global.</p>
<p>Beware that the transliterate command requires all the characters both
in the original and destination set to be given verbatim. That means the
following Sed program does not do what you might think at first sight:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># BEWARE: this doesn&#39;t do what you may think!</span>
</span></span><span style="display:flex;"><span>sed &lt; inputfile -e <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/:.*//
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  y/[a-z]/[A-Z]/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><h2 id="the-last-word"><a name="the-last-word"></a>
The last word</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># What will this do?</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Hint: the answer is not far away...</span>
</span></span><span style="display:flex;"><span>sed -E <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  s/.*\W(.*)/\1/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  h
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  ${ x; p; }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  d&#39;</span> &lt; inputfile
</span></span></code></pre></div><p>I can’t believe we did it! We’ve reviewed all the Sed commands. If you
reached that point, you deserve congratulations, especially if you took
the time to try the different examples on your system!</p>
<p>As you’ve seen, Sed is a complex beast, not only because of its sparse
syntax but also because of all the various corner cases or subtle
differences in the command behavior. No doubt, we can blame historical
reasons for that. Despite these drawbacks, it is a powerful tool and
like <a href="https://linuxhandbook.com/awk-command-tutorial/">AWK command</a>,
even today remains one of the most useful commands of the Unix toolbox.</p>
<p>If it is time for me to conclude that article, I wouldn’t do it without
first asking you a favor: please, share with us using the command
section your most favorite or creative piece of Sed script. If we have
enough of them, we could publish a compilation of those Sed gems!</p>
</article>
    </section>

    
    <article class="ui segment post-disqus-area" data-html2canvas-ignore>
      <div id="disqus_thread"></div>
      <script>
        


        var disqus_config = function () {
          this.page.url = 'https:\/\/lsq.github.io\/posts\/sed-reference-guide\/';  
          this.page.identifier = '\/posts\/sed-reference-guide\/'; 
        };

        (function() { 
          var d = document, s = d.createElement('script');
          s.src = 'https://' + 'lsq' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </article>
    

    
    <article class="ui segment utterances-comments" data-html2canvas-ignore>
      <script
        src="https://utteranc.es/client.js"
        repo="lsq/lsq.github.io"
        issue-term="og:title"
        theme="github-light"
        crossorigin="anonymous"
        async>
      </script>
    </article>
    

    
  </div>
</div>


            <footer class="ui basic center aligned segment" style="background-color: transparent;">
              
              <p>© 2011 - 2022 lsq 的博客</p>
              

              <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</p>

              
            </footer>
          </div>
        </section>
        <section class="back">
          <div class="dream-max-width">
            <header class="ui basic very padded segment dream-header">
  <div class="ui small circular image">
    
    <img src="/me/pk.jpg" alt="avatar" />
    
  </div>

  <div class="content">
    <h1 class="ui medium header">lsq的博客<div class="sub header">世界经济史是一部基于假象和谎言的连续剧</div>
    </h1>

    <article class="ui horizontal list">
      
      <a class="item" href="/posts">
        <i class="archive icon" title="归档"></i>
      </a>
      
      <a class="item" href="/categories">
        <i class="th list icon" title="所有分类"></i>
      </a>
      <a class="item" href="/tags">
        <i class="tags icon" title="所有标签"></i>
      </a>
    </article>

    
    <article class="dream-tags">
    
      <a class="ui label" href="/tags/bash/" title="bash">
        bash
      </a>
    
      <a class="ui label" href="/tags/bos/" title="BOS">
        BOS
      </a>
    
      <a class="ui label" href="/tags/design-patterns/" title="design-patterns">
        design-patterns
      </a>
    
      <a class="ui label" href="/tags/development/" title="development">
        development
      </a>
    
      <a class="ui label" href="/tags/emf/" title="emf">
        emf
      </a>
    
      <a class="ui label" href="/tags/enumitem/" title="enumitem">
        enumitem
      </a>
    
      <a class="ui label" href="/tags/git/" title="git">
        git
      </a>
    
      <a class="ui label" href="/tags/go/" title="go">
        go
      </a>
    
      <a class="ui label" href="/tags/golang/" title="golang">
        golang
      </a>
    
      <a class="ui label" href="/tags/hugo/" title="hugo">
        hugo
      </a>
    
      <a class="ui label" href="/tags/iconv/" title="iconv">
        iconv
      </a>
    
      <a class="ui label" href="/tags/images/" title="images">
        images
      </a>
    
      <a class="ui label" href="/tags/js/" title="“js&#34;">
        “js&#34;
      </a>
    
      <a class="ui label" href="/tags/latex/" title="LaTex">
        LaTex
      </a>
    
      <a class="ui label" href="/tags/notes/" title="notes">
        notes
      </a>
    
      <a class="ui label" href="/tags/pdf/" title="pdf">
        pdf
      </a>
    
      <a class="ui label" href="/tags/png/" title="png">
        png
      </a>
    
      <a class="ui label" href="/tags/power-query/" title="power query">
        power query
      </a>
    
      <a class="ui label" href="/tags/printf/" title="printf">
        printf
      </a>
    
      <a class="ui label" href="/tags/python/" title="Python">
        Python
      </a>
    
      <a class="ui label" href="/tags/ruby/" title="ruby">
        ruby
      </a>
    
      <a class="ui label" href="/tags/sed/" title="sed">
        sed
      </a>
    
      <a class="ui label" href="/tags/spider/" title="spider">
        spider
      </a>
    
      <a class="ui label" href="/tags/templates/" title="templates">
        templates
      </a>
    
      <a class="ui label" href="/tags/tex/" title="Tex">
        Tex
      </a>
    
      <a class="ui label" href="/tags/themes/" title="themes">
        themes
      </a>
    
      <a class="ui label" href="/tags/vba/" title="vba">
        vba
      </a>
    
      <a class="ui label" href="/tags/vim/" title="vim">
        vim
      </a>
    
      <a class="ui label" href="/tags/xxd/" title="xxd">
        xxd
      </a>
    
      <a class="ui label" href="/tags/%E4%BA%BA%E7%89%A9/" title="人物">
        人物
      </a>
    
      <a class="ui label" href="/tags/%E5%85%83%E7%BC%96%E7%A8%8B/" title="元编程">
        元编程
      </a>
    
      <a class="ui label" href="/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="泛型编程">
        泛型编程
      </a>
    
      <a class="ui label" href="/tags/%E8%B4%A2%E5%8A%A1/" title="财务">
        财务
      </a>
    
      <a class="ui label" href="/tags/%E9%87%91%E8%9D%B6%E4%BA%91%E6%98%9F%E7%A9%BA/" title="金蝶云星空">
        金蝶云星空
      </a>
    
    </article>
    
  </div>
</header>


<div class="ui relaxed grid dream-grid dream-back">
  
  
  
  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article class="ui segment markdown-body">
      <div class="ui medium header">关于我</div>
      <p>lsq 的 ❤️ 博客</p>
<p>记录一些 🌈 生活上，财务相关技术上的事</p>
<p>毕业于 🏫 东北财经大学</p>
<p>空闲时间会做分享财务工作上相关技术</p>
<p>主要分享是：</p>
<ul>
<li>VBA &amp; Power Query</li>
<li>Excel 图表制作</li>
<li>LaTeX</li>
</ul>
<p>写着玩：</p>
<ul>
<li>Ruby</li>
<li>Bash shell</li>
<li>Python</li>
</ul>
<p>目前在深圳工作</p>
<p>&ndash; 2021 年 04 月 11 日更新</p>

    </article>
  </div>
  

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article class="ui segment">
      <div class="ui medium header">社交链接</div>
      <nav class="ui secondary menu dream-menu dream-socials">
  
  <div class="item">
    <a href="/index.xml">
      <i class="large rss square icon" title="RSS"></i>
    </a>
  </div>
  

  
  <div class="item">
    <a href="mailto:lsqypj@gmail.com">
      <i class="large mail icon" title="Email"></i>
    </a>
  </div>
  

  

  

  

  

  

  
  <div class="item">
    <a href="https://github.com/lsq" target="_blank">
      <i class="large github icon" title="GitHub"></i>
    </a>
  </div>
  

  

  
</nav>

    </article>
  </div>

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    
    <article class="ui segment">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。<br /><br />背景使用了 <a href="https://www.pexels.com/zh-cn/" target="_blank">Pexels</a> 上 <a href="https://www.pexels.com/zh-cn/@minan1398" target="_blank">Min An</a> 拍摄的<a href="https://www.pexels.com/zh-cn/photo/1454794/" target="_blank">图片</a>。
    </article>
    
  </div>

  
  
</div>

          </div>
        </section>
      </div>
    </div>

    <script>
  window.defaultDark =  null 
  window.backgroundDark =  null 
  window.backgroundImageDark = "/me/background.jpg"
  window.darkNav =  null 
  window.hasTwitterEmbed =  null 

  if (window.hasTwitterEmbed) {
    
    window.twttr = (function (d, s, id) {
      var js,
        fjs = d.getElementsByTagName(s)[0],
        t = window.twttr || {}
      if (d.getElementById(id)) return t
      js = d.createElement(s)
      js.id = id
      js.src = 'https://platform.twitter.com/widgets.js'
      fjs.parentNode.insertBefore(js, fjs)

      t._e = []
      t.ready = function (f) {
        t._e.push(f)
      }

      return t
    })(document, 'script', 'twitter-wjs')
  }
</script>
<script src="/js/jquery.min.js"></script>
<script src="/js/semantic.min.js"></script>
<script src="/js/jquery.overlayScrollbars.min.js"></script>
<script src="/js/header.js"></script>
<script src="/js/main.js"></script>
<script src="/js/theme.js"></script>

    
<script src="/js/html2canvas.min.js"></script>
<script src="/js/post.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>



<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/clojure.min.js"></script>

<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ocaml.min.js"></script>



<script>
  hljs.initHighlightingOnLoad()
  setHighlightTheme()

  function setHighlightTheme() {
    var isDark = localStore.getItem('hugo-theme-dream-is-dark')
    isDark = isDark ? isDark : window.defaultDark ? 'y' : isDark

    var lightTheme = "tomorrow"
    var darkTheme = "tomorrow-night"
    var theme = isDark === 'y' ? darkTheme : lightTheme

    $('link[data-highlight]').attr('href', 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/' + theme + '.min.css')
    $('pre').css('background', isDark === 'y' ? '#333' : '')
  }
</script>





    
    <div class="ui inverted segment" id="dream-search">
  <div class="ui search">
    <div class="ui transparent input">
      <input class="prompt" type="text" placeholder="搜索" />
    </div>
    <div class="results"></div>
  </div>
</div>
<script>
  $(document).ready(function () {
    $.getJSON('https:\/\/lsq.github.io/index.json', function (data) {
      $('.ui.search').search({
        source: data,
        searchFields: ['title'],
        showNoResults: true,
      })
    })
  })
</script>
<script src="/js/search.js"></script>

    

    

    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-98295641-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
  </body>
</html>
