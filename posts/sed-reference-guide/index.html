<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Hugo blog</title>
  <link rel="icon" type="image/png" href="https://lsq.github.io/images/favicon.png">
  <link href="//at.alicdn.com/t/font_1022901_2zjuy2ajfyt.css" rel="stylesheet">
  <link href="https://cdn.bootcss.com/Swiper/4.4.6/css/swiper.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  
  
  
  <link href="/assets/style.css" rel="stylesheet">
</head>
<body>
<nav class="navbar navbar-top" id="navbar">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">
          
          <img class="logo" src="https://16pixel.github.io/cherry/images/logo.png" width="42" height="42" alt="logo">
      </a>
      <div class="navbar-burger" id="navbar-burger">
        <span></span> <span></span> <span></span>
      </div>
    </div>
    <div class="navbar-menu" id="navbar-menu">
      <div class="navbar-start">
        
        
          <a href="https://lsq.github.io/categories/"
             class="navbar-item ">
            <i class='icon icon-category'></i>
            分类
          </a>
        
          <a href="https://lsq.github.io/tags/"
             class="navbar-item ">
            <i class='icon icon-tag'></i>
            标签
          </a>
        
          <a href="https://lsq.github.io/series/"
             class="navbar-item ">
            <i class='icon icon-post'></i>
            系列
          </a>
        
          <a href="https://lsq.github.io/about/"
             class="navbar-item ">
            
            关于
          </a>
        
          <a href="https://lsq.github.io/posts/goisforlovers/"
             class="navbar-item ">
            
            (Hu)go Template Primer
          </a>
        
          <a href="https://lsq.github.io/posts/hugoisforlovers/"
             class="navbar-item ">
            
            Getting Started with Hugo
          </a>
        
          <a href="https://lsq.github.io"
             class="navbar-item ">
            
            tutorials
          </a>
        
      </div>
      <div class="navbar-end">
        
          <div class="navbar-item btn-search" data-target="#modal-search">
            <i class="icon icon-search"></i>
            搜索
          </div>
        
        <div class="modal" id="modal-search">
          <div class="modal-content">
            <header class="modal-header" style="padding-right: 40px">
              <div class="form-group" style="margin-bottom: 0">
                <div class="form-field form-icon-left">
                  <input type="search" class="form-control" placeholder="搜索" id="search">
                  <i class="icon icon-search form-icon"></i>
                </div>
              </div>
              <div class="modal-close">×</div>
            </header>
            <section class="modal-body" id="search-content"></section>
          </div>
        </div>
      </div>
    </div>
  </div>
</nav>


<div class="container" id="main">
  <div class="row">
    <div class="col-md-9">
      <div class="single series">
        <h1 class="single-title">Complete Sed Command Guide</h1>
        <div class="vio-meta">
  <div class="vio-date">
    Nov 18, 2019
  </div>
  
    <div class="vio-categories">
      
        
        <a class="vio-category" href="https://lsq.github.io/categories/linux%20command%20tools">
          linux command tools
        </a>
      
    </div>
  
</div>

        <div class="separator"></div>
        <div class="single-content">
          <h1 id="complete-sed-command-guide-explained-with-practical-examples">Complete Sed Command Guide [Explained with Practical Examples]</h1>
<p>In a previous article, I showed the <a href="https://linuxhandbook.com/sed-command-basics/">basic usage of
Sed</a>, the stream editor,
on a practical use case. Today, be prepared to gain more insight about
Sed as we will take an in-depth tour of the sed execution model. This
will be also an opportunity to make an exhaustive review of all Sed
commands and to dive into their details and subtleties. So, if you are
ready, launch a terminal, <a href="https://gist.github.com/s-leroux/5cb36435bac46c10cfced26e4bf5588c">download the test
files</a>
and sit comfortably before your keyboard: we will start our exploration
right now!</p>
<p>Table of Contents</p>
<ul>
<li><a href="#_a_little_bit_of_theory">A little bit of theory</a>
<ul>
<li><a href="#_a_first_look_at_the_sed_execution_model">A first look at the sed execution
model</a></li>
<li><a href="#_the_sed_abstract_machine">The Sed abstract machine</a></li>
<li><a href="#_a_more_accurate_sed_execution_model">A more accurate Sed execution
model</a></li>
</ul>
</li>
<li><a href="#_the_print_command">The print command</a></li>
<li><a href="#addresses">Addresses</a>
<ul>
<li><a href="#_line_numbers">Line numbers</a></li>
<li><a href="#regex">Regular expressions</a></li>
<li><a href="#_extended_regular_expressions">Extended regular expressions</a></li>
<li><a href="#_the_bracket_quantifier">The bracket quantifier</a></li>
<li><a href="#range">Range addresses</a></li>
<li><a href="#_complement">Complement</a></li>
<li><a href="#_conjunctions">Conjunctions</a></li>
</ul>
</li>
<li><a href="#_the_quit_command">The quit command</a></li>
<li><a href="#substitution">The substitution command</a>
<ul>
<li><a href="#_the_delete_command">The delete command</a></li>
<li><a href="#_the_next_command">The next command</a></li>
</ul>
</li>
<li><a href="#_working_with_the_hold_space">Working with the hold space</a>
<ul>
<li><a href="#exchange">The exchange command</a></li>
<li><a href="#hold">The hold commands</a></li>
<li><a href="#get">The get command</a></li>
</ul>
</li>
<li><a href="#_print_delete_and_next_revisited">print, delete and next
revisited</a></li>
<li><a href="#branches">Branching</a>
<ul>
<li><a href="#_labels_and_branches">labels and branches</a></li>
<li><a href="#_conditional_branch">Conditional branch</a></li>
</ul>
</li>
<li><a href="#_handling_verbatim_text">Handling verbatim text</a>
<ul>
<li><a href="#_the_change_command">The change command</a></li>
<li><a href="#_the_insert_command">The insert command</a></li>
<li><a href="#_the_append_command">The append command</a></li>
<li><a href="#read">The read command</a></li>
</ul>
</li>
<li><a href="#_alternate_output">Alternate output</a>
<ul>
<li><a href="#write">The write command</a></li>
<li><a href="#write-flag">The substitution command <code>write</code> flag</a></li>
</ul>
</li>
<li><a href="#comment">Comments</a></li>
<li><a href="#_the_commands_you_will_rarely_need">The commands you will rarely
need</a>
<ul>
<li><a href="#_the_line_number_command">The line number command</a></li>
<li><a href="#_the_unambiguous_print_command">The unambiguous print command</a></li>
<li><a href="#_the_transliterate_command">The transliterate command</a></li>
</ul>
</li>
<li><a href="#_the_last_word">The last word</a></li>
</ul>
<!-- raw HTML omitted -->
<h3 id="a-little-bit-of-theory-on-sed">A little bit of theory on Sed</h3>
<hr>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05/sed-reference-guide.jpeg?resize=800%2C450" alt="complete reference guide to sedcommands"></p>
<h3 id="a-first-look-at-the-sed-execution-model">A first look at the sed execution model</h3>
<!-- raw HTML omitted -->
<p>To truly understand Sed you must first understand the tool execution
model.</p>
<p>When processing data, Sed reads one line of input at a time and stores
it into the so-called <em>pattern space</em>. All Sed’s transformations apply
to the pattern space. Transformations are described by one-letter
commands provided on the command line or in an external Sed script file.
Most Sed commands can be preceded by an address, or an address range, to
limit their scope.</p>
<p>By default, Sed prints the content of the pattern space at the end of
each processing cycle, that is, just before overwriting the pattern
space with the next line of input. We can summarize that model like
that:</p>
<ol>
<li>
<p>Try to read the next input line into the pattern space</p>
</li>
<li>
<p>If the read was successful:</p>
<p>a.  Apply in the script order all commands whose address matches the
current input line</p>
<p>b.  If sed was not launched in quiet mode (<code>-n</code>) print the content
of the (potentially modified) pattern space</p>
<p>c.  got back to 1.</p>
</li>
</ol>
<p>Since the content of the pattern space is lost after each line is
processed, it is not suitable for long-term storage. For that purpose,
Sed has a second buffer, the <em>hold space</em>. Sed never clears, puts or
gets data from the hold space unless you explicitly request it. We will
investigate that more in depth later when studying the
<a href="#exchange">exchange</a>, <a href="#get">get</a> and <a href="#hold">hold</a> commands.</p>
<h3 id="the-sed-abstract-machine-a-namethesedabstractmachine-a">The Sed abstract machine <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p>The model explained above is what you will see described in many Sed
tutorials. Indeed, it is correct enough to understand the most basic Sed
programs. But when you start digging into more advanced commands, you
will see it is not sufficient. So let’s try to be a little bit more
formal now.</p>
<p>Actually, Sed can be viewed as implementing an <a href="http://mathworld.wolfram.com/AbstractMachine.html">abstract
machine</a> whose
<a href="https://en.wikipedia.org/wiki/State_(computer_science)">state</a> is
defined by three <a href="https://en.wikipedia.org/wiki/Data_buffer">buffers</a>,
two
<a href="https://en.wikipedia.org/wiki/Processor_register#Categories_of_registers">registers</a>,
and two <a href="https://www.computerhope.com/jargon/f/flag.htm">flags</a>:</p>
<ul>
<li>
<p><strong>three buffers</strong> to store arbitrary length text. Yes: <em>three</em>! In
the basic execution model we talked about the pattern- and
hold-space, but Sed has a third buffer: the <em>append queue</em>. From the
Sed script perspective, it is a write-only buffer that Sed will
flush automatically at predefined moments of its execution (broadly
speaking before reading a new line from the input, or just before
quitting).</p>
</li>
<li>
<p>Sed also maintains <strong>two registers</strong>: the <em>line counter</em> (LC) which
holds the number of lines read from the input, and the <em>program
counter</em> (PC) which always hold the index (“position” in the script)
of the next command to execute. Sed automatically increments the PC
as part of its main loop. But using specific commands, a script can
also directly modify the PC to skip or repeat parts of the program.
This is how loops or conditional statements can be implemented with
Sed. More on that in the dedicated <a href="#branches">branches section</a>
below.</p>
</li>
<li>
<p>Finally <strong>two flags</strong> can modify the behavior of certain Sed
commands: the <em>auto-print flag</em> (AP) the <em>substitution flag</em> (SF).
When the auto-print flag is <em>set</em>, Sed will automatically print the
content of the pattern space <em>before</em> overwriting it (notably before
reading a new line of input but not only). When the auto-print flag
is <em>clear</em> (“not set”), Sed will never print the content of the
pattern space without an explicit command in the script. You can
clear the auto-print flag by running Sed in “quiet mode” (using the
<code>-n</code> command line option or by using the <a href="#comment">special
comment</a><code>#n</code> on the very first line or the script). The
“substitution flag” is set by the <a href="#substitution">substitution
command</a> (the <code>s</code> command) when both its address and
search pattern match the content of the pattern space. The
substitution flag is cleared at the start of each new cycle, or when
a new line is read from input, or after a conditional branch is
taken. Here again, we will revisit that topic in details in the
<a href="#branches">branches section</a>.</p>
</li>
</ul>
<p>In addition, Sed maintains the list of commands having entered their
address range (more on that of the <a href="#range">range addresses</a> section) as
well as a couple of file handles to read and write data. You will find
some more information on that in the <a href="#read">read</a> and <a href="#write">write</a>
command description.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="a-more-accurate-sed-execution-model">A more accurate Sed execution model</h3>
<p>As a picture worth thousands of words, I draw a flowchart describing the
Sed execution model. I left a couple of things aside, like dealing with
multiple input files or error handling, but I think this should be
sufficient for you to understand the behavior of any Sed program and to
avoid wasting your time by groping around while writing your own Sed
scripts.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-flowchart.png" alt="The Sed executionmodel">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-flowchart.png" alt="The Sed executionmodel"></p>
<p>You may have noticed I didn’t describe the command-specific actions in
the flowchart above. We will see that in detail for each command. So,
without further ado, let’s start our tour!</p>
<h2 id="the-print-command"><!-- raw HTML omitted --><!-- raw HTML omitted -->
The print command</h2>
<p>The print command (<code>p</code>) displays the content of the pattern space at the
moment it is executed. It does not change in any way the state of the
Sed abstract machine.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-print-command.png" alt="The Sed \`print\`command">
<img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-print-command.png" alt="The Sed \`print\`command"></p>
<p>For example:</p>
<pre><code>sed -e 'p' inputfile
</code></pre>
<p>The command above will print each line of the input file … twice. Once
because you <em>explicitly</em> requested it using the <code>print</code> command, and a
second time <em>implicitly</em> at the end of the processing loop (because we
didn’t launch Sed in “quiet mode” here).</p>
<p>If we are not interested in seeing each line twice, we have two way of
fixing that:</p>
<pre><code>sed -n -e 'p' inputfile # quiet mode with explicit print
sed -e '' inputfile  # empty &quot;do nothing&quot; program, implicit print
</code></pre>
<p>Note: the <code>-e</code> option introduces a Sed command. It is used to
distinguish between commands and file names. Since a Sed invocation must
contain at least one command, the <code>-e</code> flag is optional for that first
command. However, I have the habit of using it, mostly for consistency
with more complex cases where I have to give multiple Sed expressions on
the command line. I let you figure by yourself if this is a good or bad
habit, but I will follow that convention in the rest of the article.</p>
<h2 id="addresses">Addresses</h2>
<p>Obviously, the print command is not very useful by itself. However, if
you add an address before the command to apply it only to some lines of
the input file, it suddenly becomes able to filter out unwanted lines
from a file. But what’s an address for Sed? And how are identified the
“lines” of the input file?</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="line-numbers">Line numbers</h3>
<p>A Sed address can be either a <em>line number</em> (with the extension of <code>$</code>
to mean “the last line”) or a <em>regular expression</em>. When using line
numbers, you have to remember lines are numbered starting from one in
Sed— and not starting from zero.</p>
<pre><code>sed -n -e '1p' inputfile # print only the first line of the file
sed -n -e '5p' inputfile # print only the line 5
sed -n -e '$p' inputfile # print the last line of the file
sed -n -e '0p' inputfile # will result in an error because 0 is not a valid line number
</code></pre>
<p>According to the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html">POSIX
specifications</a>,
line numbers are cumulative if you specify several input files. In other
words, the line counter is not reset when Sed opens a new input file.
So, the two commands below will do the same thing, printing only one
line of text to the output:</p>
<pre><code>sed -n -e '1p' inputfile1 inputfile2 inputfile3
cat inputfile1 inputfile2 inputfile3 | sed -n -e '1p'
</code></pre>
<p>Actually, this is exactly how POSIX defines multiple file handling:</p>
<blockquote>
<p>If multiple file operands are specified, the named files shall be read
in the order specified and the concatenation shall be edited.</p>
</blockquote>
<p>However, some Sed implementations offer command line options to change
that behavior, like the GNU Sed <code>-s</code> flag (which is implicitly applied
too when using the GNU Sed <code>-i</code> flags):</p>
<pre><code>sed -sn -e '1p' inputfile1 inputfile2 inputfile3
</code></pre>
<p>If your implementation of Sed supports such non-standard options, I let
you check into the <code>man</code> for the details regarding them.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="regular-expressions">Regular expressions</h3>
<p>I’ve said Sed addresses could be line numbers or regular expressions.
But what is this <em>regex</em> thing?</p>
<p>In just a few words, a <a href="https://www.regular-expressions.info/">regular
expression</a> is a way to describe
a <em>set</em> of strings. If a given string pertains to the set described by a
regular expression, we said the string matches the regular expression.</p>
<p>A regular expression may contain literal characters that must be present
verbatim into a string to have a match. For example, all letters and
digits behave that way, as well as most printable characters. However,
some symbols have a special meaning:</p>
<ul>
<li>
<p>They could represent anchors, like <code>^</code> and <code>$</code> that respectively
denotes the start or end of a line;</p>
</li>
<li>
<p>other symbols can serve as placeholders for entire sets of
characters (like the dot that matches any single characters or the
square brackets that are used to define a custom character set);</p>
</li>
<li>
<p>others again are quantifiers that serve to denotes repetitions (like
the <a href="https://chortle.ccsu.edu/FiniteAutomata/Section07/sect07_16.html">Kleene
star</a>
that means 0, 1 or several occurrences of the previous pattern).</p>
</li>
</ul>
<p>My goal here is not to give you a regular expression tutorial. So I will
stick with just a few examples. However, feel free to search for more on
the web about that topic: regular expressions are a really powerful
feature available in many standard Unix commands and programming
language and a skill every Unixien should master.</p>
<p>Here are few examples used in the context of a Sed address:</p>
<pre><code>sed -n -e '/systemd/p' inputfile # print only lines *containing* the literal string &quot;systemd&quot;
sed -n -e '/nologin$/p' inputfile # print only lines ending with &quot;nologin&quot;
sed -n -e '/^bin/p' inputfile # print only lines starting with &quot;bin&quot;
sed -n -e '/^$/p' inputfile # print only empty lines (i.e.: nothing between the start and end of a line)
sed -n -e '/./p' inputfile # print only lines containing a character (i.e. print only non-empty lines)
sed -n -e '/^.$/p' inputfile # print only lines containing exactly one character
sed -n -e '/admin.*false/p' inputfile # print only lines containing &quot;admin&quot; followed by &quot;false&quot; (with any number of arbitrary characters between them)
sed -n -e '/1[0,3]/p' inputfile # print only lines containing a &quot;1&quot; followed by a &quot;0&quot; or &quot;3&quot;
sed -n -e '/1[0-2]/p' inputfile # print only lines containing a &quot;1&quot; followed by a &quot;0&quot;, &quot;1&quot;, &quot;2&quot; or &quot;3&quot;
sed -n -e '/1.*2/p' inputfile # print only lines containing the character &quot;1&quot; followed by a &quot;2&quot; (with any number of arbitrary characters between them)
sed -n -e '/1[0-9]*2/p' inputfile # print only lines containing the character &quot;1&quot; followed by zero, one or more digits, followed by a &quot;2&quot;
</code></pre>
<p>If you want to remove the special meaning of a character in a regular
expression (including the regex delimiter symbol), you have to precede
it with a slash:</p>
<pre><code># Print all lines containing the string &quot;/usr/sbin/nologin&quot;
sed -ne '/\/usr\/sbin\/nologin/p' inputfile
</code></pre>
<p>You are not limited to use only the slash as the regular expression
delimiter in an address. You can use any other character that could suit
your needs and tastes by preceding the first delimiter by a backslash.
This is particularly useful when you have addresses that should match
literal slashes like when working with file paths:</p>
<pre><code># Both commands are perfectly identical
sed -ne '/\/usr\/sbin\/nologin/p' inputfile
sed -ne '\=/usr/sbin/nologin=p' inputfile
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="extended-regular-expressions">Extended regular expressions</h3>
<p>By default, the Sed regular expression engine only understands the
<a href="https://www.regular-expressions.info/posix.html#bre">POSIX basic regular
expression</a> syntax.
If you need <a href="https://www.regular-expressions.info/posix.html#ere">extended regular
expressions</a>, you
must add the <code>-E</code> flag to the Sed command. Extended regular expressions
add a couple of extra feature to basic regular expressions and, most
important maybe, they require far fewer backslashes. I let you compare:</p>
<pre><code>sed -n -e '/\(www\)\|\(mail\)/p' inputfile
sed -En -e '/(www)|(mail)/p' inputfile
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-bracket-quantifier">The bracket quantifier</h3>
<p>One powerful feature of regular expressions is the <a href="https://www.regular-expressions.info/repeat.html#limit">range
quantifier</a><code>{,}</code>.
Actually, when written exactly like that, this quantifier is a perfect
synonym for the <code>*</code> quantifier. However, you can explicitly add a lower
and upper bound on each side of the coma, something that gives a
tremendous amount of flexibility. When the lower bound of the range
quantifier is omitted, it is assumed to be zero. When the upper bound is
omitted, it is assumed to be the infinity:</p>
<p>Bracket notation   Shorthand   Description</p>
<hr>
<p>{,}                *          zero, one or many occurrences of the preceding regex
{,1}               ?           zero or one occurrence of the preceding regex
{1,}               +           one or many occurrences of the preceding regex
{n,n}              {n}         exactly n occurrences of the preceding regex</p>
<p>The bracket notation is available in basic regular expressions too, but
it requires backslashes. According to POSIX, the only quantifiers
available in basic regular expression are the star and the bracket
notation (with backslashes <code>\{m,n\}</code>). Many regex engines do support the
<code>\?</code> and <code>\+</code> notation as an extension. However, why tempting the devil?
If you need those quantifiers, using extended regular expressions will
be both easier to write and more portable.</p>
<p>If I took the time to talk about the bracket notation for regex
quantifiers, this is because that feature is often useful in Sed scripts
to count characters.</p>
<pre><code>sed -En -e '/^.{35}$/p' inputfile # Print lines containing exactly 35 characters
sed -En -e '/^.{0,35}$/p' inputfile # Print lines containing 35 characters or less
sed -En -e '/^.{,35}$/p' inputfile # Print lines containing 35 characters or less
sed -En -e '/^.{35,}$/p' inputfile # Print lines containing 35 characters or more
sed -En -e '/.{35}/p' inputfile # I let you figure out this one by yourself (test it!)
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="range-addresses">Range addresses</h3>
<p>All the addresses we used so far were unique addresses. When using an
unique address, the command is applied only the line(s) matching that
address. However, Sed also supports range addresses. They are used to
apply a command to all lines <em>between</em> the start and the end address of
the range:</p>
<pre><code>sed -n -e '1,5p' inputfile # print only lines 1 through 5
sed -n -e '5,$p' inputfile # print from line 5 to the end of the file

sed -n -e '/home/217283.cloudwaysapps.com/wgnxdnqkza/public_html/,/systemd/p' inputfile # print from the first line matching the /home/217283.cloudwaysapps.com/wgnxdnqkza/public_html/ regular expression to the next line matching the /systemd/ regular expression.
</code></pre>
<p>If the same line <em>number</em> is used both for the start and end address,
the range is reduced to that line. Actually, if the second address is a
number less than or equal to the line number of the first selected line
of the range, only one line will be selected:</p>
<pre><code>printf &quot;%s\n&quot; {a,b,c}{d,e,f} | cat -n | sed -ne '4,4p'
     4    bd
printf &quot;%s\n&quot; {a,b,c}{d,e,f} | cat -n | sed -ne '4,3p'
     4    bd
</code></pre>
<p>This is somewhat tricky, but the rule given in the previous paragraph
also applies when the <em>start address is a regular expression</em>. In that
case, Sed will compare the <em>line number</em> of the first line matching the
regex with the explicit <em>line number</em> given as end address. Once again,
if the end line number is lower or equal to the start line number, the
range will be reduced to one line:</p>
<pre><code># The /b/,4 address will match *three* one-line range
# since each matching line has a line number &gt;= 4
printf &quot;%s\n&quot; {a,b,c}{d,e,f} | cat -n | sed -ne '/b/,4p'
     4  bd
     5  be
     6  bf

# I let you figure by yourself how many ranges are matched
# by that second example:
printf &quot;%s\n&quot; {a,b,c}{d,e,f} | cat -n | sed -ne '/d/,4p'
     1  ad
     2  ae
     3  af
     4  bd
     7  cd
</code></pre>
<p>However, the behavior of Sed is different when the end address is a
<em>regular expression</em>. In that case, the first line of the range is <em>not</em>
tested against the end address, so the range will contain at least two
lines (except of course if there is not enough input data):</p>
<pre><code>printf &quot;%s\n&quot; {a,b,c}{d,e,f} | cat -n | sed -ne '/b/,/d/p'
     4    bd
     5    be
     6    bf
     7    cd

printf &quot;%s\n&quot; {a,b,c}{d,e,f} | cat -n | sed -ne '4,/d/p'
     4    bd
     5    be
     6    bf
     7    cd
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="complement">Complement</h3>
<p>Adding an exclamation mark (<code>!</code>) after an address select lines <em>not</em>
matching that address. For example:</p>
<pre><code>sed -n -e '5!p' inputfile # Print all lines except line 5
sed -n -e '5,10!p' inputfile # Print all lines except line 5 to 10
sed -n -e '/sys/!p' inputfile # Print all lines except those containing &quot;sys&quot;
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="conjunctions">Conjunctions</h3>
<p>Sed allows to group commands in blocks using brackets (<code>{…​}</code>). You can
leverage that feature to combine several addresses. For example, let’s
compare the output of those two commands:</p>
<pre><code>sed -n -e '/usb/{
/daemon/p
}' inputfile

sed -n -e '/usb.*daemon/p' inputfile
</code></pre>
<p>By nesting commands in a block, we will select lines containing “usb”
and “daemon” in any order. Whereas the regular expression “usb.*daemon”
would only match lines where the “usb” string appears before the
“daemon” string.</p>
<p>After that long digression, let’s go back now to our review of the
various Sed commands.</p>
<h2 id="the-quit-command"><!-- raw HTML omitted --><!-- raw HTML omitted -->
The quit command</h2>
<p>The quit command will stop Sed at the end of the current processing loop
iteration.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-quit-command.png" alt="The Sed \`quit\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-quit-command.png" alt="The Sed \`quit\`command"></p>
<p>The <code>quit</code> command is a way to stop input processing before reaching the
end of the input file. Why would someone want to do that?</p>
<p>Well, if you remember, we’ve seen you can print the lines 1 through 5 of
a file using the following command:</p>
<pre><code>sed -n -e '1,5p' inputfile
</code></pre>
<p>With most implementations of Sed, the tool will read and cycle over all
the remaining input lines, even if only the first five can produce a
result. This may have a significant impact if your file contains
millions of rows (or even worst, if you read from an infinite stream of
data like <code>/dev/urandom</code> for example).</p>
<p>Using the quit command, the same program can be rewritten much more
efficiently:</p>
<pre><code>sed -e '5q' inputfile
</code></pre>
<p>Here, since I did not use the <code>-n</code> option, Sed will implicitly print the
pattern space at the end of each cycle, but it will quit, and thus not
reading more data, after having processed the line 5.</p>
<p>We could use a similar trick to print only a specific line of a file.
That will be a good occasion to see several ways of providing multiple
Sed expressions from the command line. The three variations bellow take
benefit of Sed accepting several commands, either as different <code>-e</code>
options, or in the same expression, but separated by newlines or
semi-colon:</p>
<pre><code>sed -n -e '5p' -e '5q' inputfile

sed -n -e '
  5p
  5q
' inputfile

sed -n -e '5p;5q' inputfile
</code></pre>
<p>If you remember it, we’ve seen earlier we can group commands using
brackets, something that we could use here to avoid repeating the same
address twice:</p>
<pre><code># By grouping commands
sed -e '5{
  p
  q
}' inputfile

# Which can be shortened as:
sed '5{p;q;}' inputfile

# As a POSIX extension, some implementations makes the semi-colon before the closing bracket optional:
sed '5{p;q}' inputfile
</code></pre>
<h2 id="the-substitution-command"><!-- raw HTML omitted --><!-- raw HTML omitted -->
The substitution command</h2>
<p>You can imagine the substitution command as the Sed equivalent to the
search-replace feature you can find on most WYSIWYG editors. An
equivalent, albeit a more powerful one though. The substitution command
being one of the best-known Sed commands, it is largely documented on
the web.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-substitution-command.png" alt="The Sed \`substitution\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-substitution-command.png" alt="The Sed \`substitution\`command"></p>
<p>We already have covered it <a href="http://linuxhandbook.com/?p=128">in a previous
article</a> so I will not repeat myself
here. However there are some key points to remember if you’re not yet
completely familiar with it:</p>
<ul>
<li>
<p>The substitution command takes two parameters: the search pattern
and the replacement string: <code>sed s/:/-----/ inputfile</code></p>
</li>
<li>
<p>The command and its arguments are separated by an arbitrary
character. Mostly by habit, 99% of the time we use a slash but any
other character can be used: <code>sed s%:%-----% inputfile</code>,
<code>sed sX:X-----X inputfile</code> or even <code>sed 's : ----- ' inputfile</code></p>
</li>
<li>
<p>By default, the substitution is applied only to the first matching
substring of the pattern space. You can change that by specifying
the match index as a flag after the command:
<code>sed 's/:/-----/1' inputfile</code>, <code>sed 's/:/-----/2' inputfile</code>,
<code>sed 's/:/-----/3' inputfile</code>, …</p>
</li>
<li>
<p>If you want to perform a substitution globally (i.e.: on each
non-overlapping match of the pattern space), you need to add the <code>g</code>
flag: <code>sed 's/:/-----/g' inputfile</code></p>
</li>
<li>
<p>In the replacement string, any occurrence of the ampersand (<code>&amp;</code>)
will be replaced by the substring matching the search pattern:
<code>sed 's/:/-&amp;&amp;&amp;-/g' inputfile</code>, <code>sed 's/…​./&amp; /g' inputfile</code></p>
</li>
<li>
<p>Parenthesis ( <code>(…​)</code> in extended regex or <code>\(…​\)</code> in basic regex)
introduce a <em>capturing group</em>. That is a part of the matching string
that can be referenced in the replacement string. <code>\1</code> is the
content of the first capturing group, <code>\2</code> the content of the second
one and so on: <code>sed -E 's/(.)(.)/\2\1/g' inputfile</code>,
<code>sed -E 's/(.):x:(.):(.*)/\1:\3/' inputfile</code> (that latter works
because <a href="https://www.regular-expressions.info/repeat.html#greedy">the star regular expression quantifier is
greedy</a>,
and matches as many characters as it can)</p>
</li>
<li>
<p>In the search pattern or the replacement string you can remove the
special meaning of any character by preceding it with a backslash:
<code>sed 's/:/--\&amp;--/g' inputfile</code>, <code>sed 's/\//\\/g' inputfile</code></p>
</li>
</ul>
<p>As all this might seem a little bit abstract, here are a couple of
examples. To start, let’s say I want to display the first field of my
test input file padded with spaces on the right up to 20 characters, I
could write something like that:</p>
<pre><code>sed &lt; inputfile -E -e '
  s/:/                    / # replace the first field separator by 20 spaces
  s/(.{20}).*/\1/           # keep only the first 20 characters of the line
  s/.*/| &amp; |/               # add vertical bars for a nice output
'
</code></pre>
<p>As a second example, if I want to change the UID/GID of the user sonia
to 1100, I could write something like that:</p>
<pre><code>sed -En -e '
  /sonia/{
    s/[0-9]+/1100/g
    p
  }' inputfile
</code></pre>
<p>Notice the <code>g</code> option at the end of the substitution command. It
modifies its behavior, so all occurrences of the search pattern are
replaced. Without that option, only the first one would be.</p>
<p>By the way, this is also a good occasion to mention the print command
displays the content of the pattern space at the moment the command is
executed. So, I can obtain a before-after output like that:</p>
<pre><code>sed -En -e '
  /sonia/{
    p
    s/[0-9]+/1100/g
    p
  }' inputfile
</code></pre>
<p>Actually, since printing a line after a substitution is a common use
case, the substitution command also accepts the <code>p</code> option for that
purpose:</p>
<pre><code>sed -En -e '/sonia/s/[0-9]+/1100/gp' inputfile
</code></pre>
<p>Finally, I won’t be exhaustive without mentioning the <code>w</code> option of the
substitution command. We will examine it in detail <a href="#write-flag">later</a>.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-delete-command">The delete command</h3>
<p>The delete command (<code>d</code>) is used to clear the pattern space and
immediately start the next cycle. By doing so, it will also skip the
implicit print of the pattern space even if the auto-print flag is set.</p>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-delete-command.png" alt="The Sed \`delete\`command">
<img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-delete-command.png" alt="The Sed \`delete\`command"></p>
<p>A particularly inefficient way of printing only the first five lines of
a file would be:</p>
<pre><code>sed -e '6,$d' inputfile
</code></pre>
<p>I let you guess why I said this was inefficient. If this is not obvious,
try to re-read the section concerning the <a href="#quit">quit command</a>. The
answer is there!</p>
<p>The delete command is particularly useful when combined with regular
expression-based addresses to remove matching lines from the output:</p>
<pre><code>sed -e '/systemd/d' inputfile
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-next-command">The next command</h3>
<p>This command prints the current pattern space if Sed is not running in
quiet mode, then, in all cases, it reads the next input line into the
pattern space and executes the <em>remaining commands of the current cycle</em>
with the new pattern space.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-next-command.png" alt="The Sed \`next\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-next-command.png" alt="The Sed \`next\`command"></p>
<p>A common use case of the next command is to skip lines:</p>
<pre><code>cat -n inputfile | sed -n -e 'n;n;p'
</code></pre>
<p>In the example above, Sed will implicitly read the first line of the
input file. But the <code>next</code> command discards (and does not display
because of the <code>-n</code> option) the pattern space and replaces it with the
next line from the input. And the second <code>next</code> command will do the same
thing, skipping now the line 2 of the input. And finally, the script
explicitly prints the pattern space which now contains the third line of
the input. Then Sed will start a new cycle, implicitly reading the line
4, then skipping it, as well as the line 5, because of the <code>next</code>
commands, and it will print the line 6. And again and again until the
end of the file. Concretely, this prints one line over three of the
input file.</p>
<p>Using the next command, we can also find a couple of other ways to
display the first five lines of a file:</p>
<pre><code>cat -n inputfile | sed -n -e '1{p;n;p;n;p;n;p;n;p}'
cat -n inputfile | sed -n -e 'p;n;p;n;p;n;p;n;p;q'
cat -n inputfile | sed -e 'n;n;n;n;q'
</code></pre>
<p>More interestingly, the next command is also very useful when you want
to process lines <em>relative</em> to some address:</p>
<pre><code>cat -n inputfile | sed -n '/pulse/p'       # print lines containing &quot;pulse&quot;
cat -n inputfile | sed -n '/pulse/{n;p}'   # print the line following
                                           # the line containing &quot;pulse&quot;
cat -n inputfile | sed -n '/pulse/{n;n;p}' # print the line following
                                           # the line following
                                           # the line containing &quot;pulse&quot;
</code></pre>
<h2 id="working-with-the-hold-space"><!-- raw HTML omitted --><!-- raw HTML omitted -->
Working with the hold space</h2>
<p>Until now, the command we’ve seen dealt only with the pattern space.
However, as we’ve mentioned it at the very top of this article, there is
a second buffer, the hold space, entirely under the control of the user.
This will be the purpose of the commands described in this section.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-exchange-command">The exchange command</h3>
<p>As it names implies it, the exchange command (<code>x</code>) will swap the content
of the hold and pattern space. Remember as long as you didn’t put
anything into the hold space, it is empty.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-exchange-command.png" alt="The Sed \`exchange\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-exchange-command.png" alt="The Sed \`exchange\`command"></p>
<p>As a first example, we may use the exchange command to print in reverse
order the first two lines of a file:</p>
<pre><code>cat -n inputfile | sed -n -e 'x;n;p;x;p;q'
</code></pre>
<p>Of course, you don’t have to use the content of the hold space
immediately after having set it, since the hold space remains untouched
as long as you don’t explicitly modify it. In the following example, I
use it to move the first line of the input after the fifth one:</p>
<pre><code>cat -n inputfile | sed -n -e '
  1{x;n}                # Swap the hold and pattern space
                        # to store line 1 into the hold buffer
                        # and then read line two
  5{
    p                   # print line 5
    x                   # swap the hold and pattern space to get
                        # back the content of line one into the
                        # pattern space
  }

  1,5p                  # triggered on lines 2 through 5
                        # (not a typo! try to figure why this rule
                        # is NOT executed for line 1;)
'
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-hold-commands">The hold commands</h3>
<p>The hold command (<code>h</code>) is used to store the content of the pattern space
into the hold space. However, as opposed to the exchange command, this
time the content of the pattern space is left unchanged. The hold
commands came in two flavors:</p>
<dl>
<dt><code>h</code></dt>
<dd>
<p>that will copy the content of the pattern space into the hold space,
overwriting any value already present</p>
</dd>
<dt><code>H</code></dt>
<dd>
<p>that will append the content of the pattern space to the hold space,
using a newline as separator</p>
</dd>
</dl>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-hold-command.png" alt="The Sed \`hold\`command">
<img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-hold-command.png" alt="The Sed \`hold\`command"></p>
<p>The example above using the exchange command can be rewritten using the
hold command instead:</p>
<pre><code>cat -n inputfile | sed -n -e '
  1{h;n}                # Store line 1 into the hold buffer and continue
  5{                    # on line 5
    x                   # switch the pattern and hold space
                        # (now the pattern space contains the line 1)
    H                   # append the line 1 after the line 5 in the hold space
    x                   # switch again to get back lines 5 and 1 into
                        # the pattern space
  }

  1,5p                  # triggered on lines 2 through 5
                        # (not a typo! try to figure why this rule
                        # is NOT executed for line 1;)
'
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-get-command">The get command</h3>
<p>The get command (<code>g</code>) does the exact opposite of the hold command: it
takes the content of the hold space and put it into the pattern space.
Here again, it comes in two flavors:</p>
<dl>
<dt><code>g</code></dt>
<dd>
<p>that will copy the content of the hold space into the pattern space,
overwriting any value already present</p>
</dd>
<dt><code>G</code></dt>
<dd>
<p>that will append the content of the hold space to the pattern space,
using a newline as separator</p>
</dd>
</dl>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-get-command.png" alt="The Sed \`get\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-get-command.png" alt="The Sed \`get\`command"></p>
<p>Together, the hold and get commands allow to store and recall data. As a
little challenge, I let you rewrite the example of the previous section
to put the line 1 of the input file after the line 5, but this time
using the get and hold commands (lower- or upper-case version), but
<em>without</em> using the exchange command. With a little bit of luck, it
should be simpler that way!</p>
<p>In the meantime, I can show you another example that could serve for
your inspiration. The goal here is to separate the users having a login
shell from the others:</p>
<pre><code>cat -n inputfile | sed -En -e '
  \=(/usr/sbin/nologin|/bin/false)$= { H;d; }
              # Append matching lines to the hold buffer
              # and continue to next cycle
  p           # Print other lines
  $ { g;p }   # On the last line,
              # get and print the content of the hold buffer
'
</code></pre>
<h2 id="print-delete-and-next-revisited"><!-- raw HTML omitted --><!-- raw HTML omitted -->
print, delete and next revisited</h2>
<p>Now you’ve gained more familiarities with the hold space, let me go back
on the <code>print</code>, <code>delete</code> and <code>next</code> commands. We already talked about
the lower case <code>p</code>, <code>d</code> and <code>n</code> commands. But they also have an upper
case version. As it seems to be a convention with Sed, the uppercase
version of those commands will be related to multi-line buffers:</p>
<dl>
<dt><code>P</code></dt>
<dd>
<p>print the content of the pattern space <em>up to the first newline</em></p>
</dd>
<dt><code>D</code></dt>
<dd>
<p>delete the content of the pattern space <em>up and including the first
newline</em> then restart a cycle with the remaining text <em>without</em>
reading any new input</p>
</dd>
<dt><code>N</code></dt>
<dd>
<p><em>read and append a new line of input</em> to the pattern space using the
newline character as a separator between the old and new data.
Continue the execution of the current cycle.</p>
</dd>
</dl>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-delete-upper-command.png" alt="The Sed uppercase \`Delete\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-delete-upper-command.png" alt="The Sed uppercase \`Delete\`command"></p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-next-upper-command.png" alt="The Sed uppercase \`Next\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-next-upper-command.png" alt="The Sed uppercase \`Next\`command"></p>
<p>The main use case for those commands is to implement queues (<a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">FIFO
lists</a>).
The canonical example being removing the last 5 lines from a file:</p>
<pre><code>cat -n inputfile | sed -En -e '
  1 { N;N;N;N }     # ensure the pattern space contains *five* lines

  N                 # append a sixth line onto the queue
  P                 # Print the head of the queue
  D                 # Remove the head of the queue
'
</code></pre>
<p>As a second example, we could display input data on two columns:</p>
<pre><code># Print on two columns
sed &lt; inputfile -En -e '
 $!N                # Append a new line to the pattern space
                    # *except* on the last line of input
                    # This is a trick required to deal with
                    # inconsistencies between GNU Sed and POSIX Sed
                    # when using N on the last line of input
                    # https://www.gnu.org/software/sed/manual/sed.html#N_005fcommand_005flast_005fline

                    # Right pad the first field of the first line
                    # with spaces and discard rest of the line
 s/:.*\n/                    \n/
 s/:.*//            # Discard all but the first field on the second line
 s/(.{20}).*\n/\1/  # Trim and join lines
 p                  # Print result
'
</code></pre>
<h2 id="branching"><!-- raw HTML omitted --><!-- raw HTML omitted -->
Branching</h2>
<p>We just saw Sed has buffer capabilities through the hold space. But it
also has test and branch instructions. Having both those features makes
Sed a <a href="https://chortle.ccsu.edu/StructuredC/Chap01/struct01_5.html">Turing
complete</a>
language. It may sound silly, but that means you can write any program
using Sed. You can do it, but that does not mean it would be an easy
task, nor that the result would be particularly efficient of course.</p>
<p>However, don’t panic. In this article, we will stay with simple examples
of tests and branches. Even if these capabilities seem limited at first
sight, remember some people have written
[calculators],
[Tetris] or many other
kinds of applications using sed!</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="labels-and-branches">labels and branches</h3>
<p>By some aspects, you can see Sed as a very limited assembly language. So
you won’t find high-level “for” or “while” loops or “if … else”
statements, but you can implement them using branches.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-branch-command.png" alt="The Sed \`branch\`command">
<img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-branch-command.png" alt="The Sed \`branch\`command"></p>
<p>If you take a look at the flowchart describing the Sed execution model
at the top of this article, you can see Sed automatically increments the
program counter, resulting in the execution of the commands in the
program’s instructions order. However, using branch instructions, you
can break that sequential flow by continuing the execution with any
command of your choice in the program. The destination of a jump is
explicitly defined using a label.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-label-command.png" alt="The Sed \`label\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-label-command.png" alt="The Sed \`label\`command"></p>
<p>Here is an example:</p>
<pre><code>echo hello | sed -ne '
  :start      # Put the &quot;start&quot; label on that line of the program
  p           # Print the pattern buffer
  b start     # Continue execution at the :start label
' | less
</code></pre>
<p>The behavior of that Sed program is very close to the <code>yes</code> command: it
takes a string and produces an infinite stream of lines containing that
string.</p>
<p>Branching to a label as we did bypass all Sed automatic features: it
does not read any input, nor print anything, nor update any buffer. It
just jumps to a different instruction instead of executing the next one
in the source program order.</p>
<p>Worth mentioning without any label specified as an argument, the branch
command (<code>b</code>) will branch to the end of the program. So Sed will start a
new cycle. This may be useful to bypass some instructions and thus may
be used as an alternative to blocks:</p>
<pre><code>cat -n inputfile | sed -ne '
/usb/!b
/daemon/!b
p
'
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="conditional-branch">Conditional branch</h3>
<p>Until now, we’ve seen the so-called unconditional branches, even if the
term is somewhat misleading in this context since Sed commands are
always conditional based on their optional address.</p>
<p>However, in a more traditional sense, an <em>unconditional</em> branch is a
branch that, when executed, will <em>always jump</em> to the specified
destination, whereas a <em>conditional</em> branch <em>may or may not jump</em> to the
specified instruction depending on the current state of the system.</p>
<p>Sed has only one conditional instruction, the test (<code>t</code>) command. It
jumps to a different instruction only if a substitution was executed
since the start of the current cycle or since the previous conditional
branch. More formally, the test command will branch only if the
<em>substitution flag</em> is set.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-test-command.png" alt="The Sed \`test\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-test-command.png" alt="The Sed \`test\`command"></p>
<p>With the test instruction, you can easily perform loops in a Sed
program. As a practical example, you can use that to pad lines to a
certain length (something you can’t do with regex only):</p>
<pre><code># Center text
cut -d: -f1 inputfile | sed -Ee '
  :start
  s/^(.{,19})$/ \1 /    # Pad lines shorter than 20 chars with
                        # a space at the start and another one
                        # at the end
  t start               # Go back to :start if we added a space
  s/(.{20}).*/| \1 |/   # Keep only the first 20 char of the line
                        # to fix the off-by-one error caused by
                        # odd lines
'
</code></pre>
<p>If you carefully read the previous example, you’ve noticed I cheated a
little bit by using the cut command to pre-process the data before
feeding them to sed.</p>
<p>We can, however, perform the same task using only sed at the cost of a
small modification to the program:</p>
<pre><code>cat inputfile | sed -Ee '
  s/:.*//               # Remove all but the first field
  t start
  :start
  s/^(.{,19})$/ \1 /    # Pad lines shorter than 20 chars with
                        # a space at the start and another one
                        # at the end
  t start               # Go back to :start if we added a space
  s/(.{20}).*/| \1 |/   # Keep only the first 20 char of the line
                        # to fix the off-by-one error caused by
                        # odd lines
'
</code></pre>
<p>In the above example, you may be surprised by the following construct:</p>
<pre><code>t start
:start
</code></pre>
<p>At first sight, the branch here seems useless since it will jump to the
instruction that would have been executed anyway. However, if you read
the definition of the <code>test</code> command attentively, you will see it
branches only <em>if there was a substitution</em> since the start of the
current cycle or <em>since the previous test command was executed</em>. In
other words, the test instruction has the side effect of clearing the
<em>substitution flag</em>. This is exactly the purpose of the code fragment
above. This is a trick you will often see in Sed programs containing
conditional branches to avoid false positive when using several
substitutions commands.</p>
<p>I agree though it wasn’t absolutely mandatory here to clear the
substitution flag since the specific substitution command I used is
idempotent once it has padded the string to the right length. So one
extra iteration will not change the result. However, look at that second
example now:</p>
<pre><code># Classify user accounts based on their login program
cat inputfile | sed -Ene '
  s/^/login=/
  /nologin/s/^/type=SERV /
  /false/s/^/type=SERV /
  t print
  s/^/type=USER /
  :print
  s/:.*//p
'
</code></pre>
<p>My hope here was to tag the user accounts with either “SERV” or “USER”
depending on the configured default login program. If you ran it, you’ve
seen the “SERV” tag as expected. However, no trace of the “USER” tag in
the output. Why? Because the <code>t print</code> instruction will <em>always</em> branch
since whatever was the content of the line, the <em>substitution flag</em> was
set by the very first substitution command of the program. Once set, the
flag remains set until a next line is read— or until the next test
command. And gives us the solution to fix that program:</p>
<pre><code># Classify user accounts based on the login program
cat inputfile | sed -Ene '
  s/^/login=/

  t classify # clear the &quot;substitution flag&quot;
  :classify

  /nologin/s/^/type=SERV /
  /false/s/^/type=SERV /
  t print
  s/^/type=USER /
  :print
  s/:.*//p
'
</code></pre>
<h2 id="handling-verbatim-text"><!-- raw HTML omitted --><!-- raw HTML omitted -->
Handling verbatim text</h2>
<p>Sed is a text editor. A non-interactive one. But a text editor
nevertheless. It wouldn’t be complete without some facility to insert
literal text in the output. I’m not a big fan of that feature since I
find the syntax awkward (even by the Sed standards), but sometimes you
can’t avoid it.</p>
<p>In the strict POSIX syntax, all the three commands to change (<code>c</code>),
insert (<code>i</code>) or append (<code>a</code>) some literal text to the output follow the
same specific syntax: the command letter is followed by a backslash, and
the text to insert start on the next line of the script:</p>
<pre><code>head -5 inputfile | sed '
1i\
# List of user accounts
$a\
# end
'
</code></pre>
<p>To insert multiple lines of text, you must end each of them with a
backslash:</p>
<pre><code>head -5 inputfile | sed '
1i\
# List of user accounts\
# (users 1 through 5)
$a\
# end
'
</code></pre>
<p>Some Sed implementations, like GNU Sed, makes the newline after the
initial backslash optional, even when forced in <code>--posix</code> mode. I didn’t
find anything in the standard that authorizes that alternate syntax. So
use it at your own risks if portability is a premium (or leave a comment
if I missed that feature in the specifications!):</p>
<pre><code># non-POSIX syntax:
head -5 inputfile | sed -e '
1i \# List of user accounts
$a\# end
'
</code></pre>
<p>Some Sed implementation also makes the initial backslash completely
optional. Since this is, without any doubt this time, a vendor-specific
extension to the POSIX specifications, I let you check the manual for
the version of sed you use to check if it supports that syntax.</p>
<p>After that quick overview, let’s review those commands in more details
now, starting with the change command I didn’t have presented yet.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-change-command">The change command</h3>
<p>The change command (<code>c\</code>) deletes the pattern space and starts a new
cycle just like the <code>d</code> command. The only difference is the user
provided text is written on the output when the command is executed.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-change-command.png" alt="The Sed \`change\`command">
<img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-change-command.png" alt="The Sed \`change\`command"></p>
<pre><code>cat -n inputfile | sed -e '
/systemd/c\
# :REMOVED:
s/:.*// # This will NOT be applied to the &quot;changed&quot; text
'
</code></pre>
<p>If the change command is associated with a <a href="#range">range address</a>, the
text is output only once, when reaching the last line of the range.
Which somehow makes it an exception to the convention a Sed command is
repeatedly applied to all lines of its range address:</p>
<pre><code>cat -n inputfile | sed -e '
19,22c\
# :REMOVED:
s/:.*// # This will NOT be applied to the &quot;changed&quot; text
'
</code></pre>
<p>As a consequence, if you want the change command to be repeated for
every line in a range, you have no other choice than wrapping it inside
a block:</p>
<pre><code>cat -n inputfile | sed -e '
19,22{c\
# :REMOVED:
}
s/:.*// # This will NOT be applied to the &quot;changed&quot; text
'
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-insert-command">The insert command</h3>
<p>The insert command (<code>i\</code>) immediately print the user-provided text on
the output. It does not alter in any way the program flow or buffer
content.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-insert-command.png" alt="The Sed \`insert\`command">
<img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-insert-command.png" alt="The Sed \`insert\`command"></p>
<pre><code># display the first five user names with a title on the first row
sed &lt; inputfile -e '
1i\
USER NAME
s/:.*//
5q
'
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-append-command">The append command</h3>
<p>The append command (<code>a\</code>) queues some text to be displayed when the next
line of input will be read. The text is output at the end of the current
cycle (including at the end of the program) or when a new line is read
from the input using either the <code>n</code> or <code>N</code> command.</p>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-append-command.png" alt="The Sed \`append\`command">
<img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-append-command.png" alt="The Sed \`append\`command"></p>
<p>Same example as above, but inserts this time a footer instead of a
header:</p>
<pre><code>sed &lt; inputfile -e '
5a\
USER NAME
s/:.*//
5q
'
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-read-command">The read command</h3>
<p>There is a fourth command to insert literal content into the output
stream: the read command (<code>r</code>). It works exactly like the append
command, but instead of taking the text hardcoded from the Sed script
itself, it will write the content of a file on the output.</p>
<p>The read command only schedules the file to be read. That latter is
effectively read when the append queue is flushed. Not when the read
command is executed. This may have implications if there are concurrent
accesses to the file to be read, if that file is not a regular file (for
example, if it’s a character device or a named pipe), or if the file is
modified during processing.</p>
<p>As an illustration, if you use the <a href="#write">write</a> command we will see
in detail in the next section together with the read command to write
and re-read from a temporary file, you may obtain some creative results
(using a French equivalent of the
<a href="https://en.wikipedia.org/wiki/Shiritori">Shiritori</a> game as an
illustration):</p>
<pre><code>printf &quot;%s\n&quot; &quot;Trois p'tits chats&quot; &quot;Chapeau d' paille&quot; &quot;Paillasson&quot; |
sed -ne '
  r temp
  a\
  ----
  w temp
'
</code></pre>
<p>We’ve now ended the list of the Sed commands dedicated to the insertion
of literal text in the stream output. My last example was mostly for
fun, but since I mentioned there the write command, that makes a perfect
transition with the next section where we will see how to write data to
an external file from Sed.</p>
<h2 id="alternate-output"><!-- raw HTML omitted --><!-- raw HTML omitted -->
Alternate output</h2>
<p>Sed is designed with the idea all text transformations will end-up being
written on the standard output of the process. However, Sed also has
some provision to send data to alternate destinations. You have two ways
to do that: using the dedicated write command, or by adding the write
flag to a substitution command.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-write-command">The write command</h3>
<p>The write command (<code>w</code>) appends the content of the pattern space to the
given destination file. POSIX requires the destination file to be
created by Sed before it starts processing any input data. If the file
already exists, it is overwritten.</p>
<p><img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-write-command.png" alt="The Sed \`write\`command">
<img src="https://i2.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-write-command.png" alt="The Sed \`write\`command"></p>
<p>As a consequence, even if you never really write to a file, it will be
created anyway. For example, the following Sed program will
create/overwrite the “output” file, even if the write command is never
executed:</p>
<pre><code>echo | sed -ne '
q         # immediately quit
w output  # this command is never executed
'
</code></pre>
<p>You can have several write commands referencing the same destination
file. All write commands at the destination of the same file will append
content to that file (more or less in the same manner as the <code>&gt;&gt;</code> shell
redirection). :</p>
<pre><code>sed &lt; inputfile -ne '
/:\/bin\/false$/w server
/:\/usr\/sbin\/nologin$/w server
w output
'
cat server
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-substitution-command-write-flag">The substitution command <code>write</code> flag</h3>
<p>A long time ago now, we had seen the substitution command has the <code>p</code>
option for the common use case of printing the pattern space after a
substitution. In a very similar manner it also has a <code>w</code> option to write
the pattern space to a file after a substitution:</p>
<pre><code>sed &lt; inputfile -ne '
s/:.*\/nologin$//w server
s/:.*\/false$//w server
'
cat server
</code></pre>
<h2 id="comments"><!-- raw HTML omitted --><!-- raw HTML omitted -->
Comments</h2>
<p>I already used them countless times, but I never took the time to
introduce them formally, so, let’s fix that: like in most programming
languages, a <em>comment</em> is a way to add free-form text the software will
not try to interpret. The Sed syntax being rather cryptic, I can’t
insist enough on the need to comment your scripts. Otherwise, they will
be hardly understandable by anyone except their author.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-comment-command.png" alt="The Sed \`comment\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-comment-command.png" alt="The Sed \`comment\`command"></p>
<p>However, like many other parts of Sed, comments have their own share of
subtleties. First, and the most important, comments are not a syntactic
construct, but are full-fledged commands in Sed. A do-nothing (“no-op”)
command, but a command anyway. At least, that is how there are defined
by POSIX. So, strictly speaking, they should only be allowed where other
commands are allowed.</p>
<p>Most Sed implementation relaxes that requirement by allowing inline
commands as I used them all over the place in that article.</p>
<p>To close on that topic, worth mentioning the very special case of the
<code>#n</code> comment (an octothorpe followed by the letter n without any space).
If that exact comment if found on the very first line of a script, Sed
should switch to quiet mode (i.e., clearing the auto-print flag) just
like if the <code>-n</code> option was specified on the command line.</p>
<h2 id="the-commands-you-will-rarely-need"><!-- raw HTML omitted --><!-- raw HTML omitted -->
The commands you will rarely need</h2>
<p>Now, we have reviewed the commands that will allow you to write 99.99%
of your scripts. But this tour wouldn’t be exhaustive if I didn’t
mention the last remaining Sed commands. I left them aside until now
because I rarely needed them. But maybe did you have on your side
examples of practical use cases where you find them useful. If that is
the case do not hesitate to share that with us using the comment
section.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-line-number-command">The line number command</h3>
<p>The <code>=</code> command writes on the standard output the number of lines
currently read by Sed, that is the content of the line counter register.
There is no way to capture that number in one of the Sed buffers, nor to
format the output. Two limitations that severely reduce the usefulness
of that command.</p>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-current-line-command.png" alt="The Sed \`line number\`command">
<img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-current-line-command.png" alt="The Sed \`line number\`command"></p>
<p>Remember in strict POSIX compliance mode, when several input files are
given on the command line, Sed does not reset that counter but continue
to increment it just like if all the files where concatenated. Some Sed
implementations like GNU Sed have options to reset the counter after
each input file.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-unambiguous-print-command">The unambiguous print command</h3>
<p>The <code>l</code> (lowercase letter ell) is similar to the print command (<code>p</code>),
but the content of the pattern space will be written in an unambiguous
form. To quote <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html">the POSIX
standard</a>:</p>
<blockquote>
<p>The characters listed in XBD Escape Sequences and Associated Actions (
‘\\’, ‘\a’, ‘\b’, ‘\f’, ‘\r’, ‘\t’, ‘\v’ ) shall be written as
the corresponding escape sequence; the ‘\n’ in that table is not
applicable. Non-printable characters not in that table shall be
written as one three-digit octal number (with a preceding
&lt;backslash&gt;) for each byte in the character (most significant
byte first). Long lines shall be folded, with the point of folding
indicated by writing a &lt;backslash&gt; followed by a
&lt;newline&gt;; the length at which folding occurs is unspecified,
but should be appropriate for the output device. The end of each line
shall be marked with a ‘$’.</p>
</blockquote>
<p><img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-unambiguous-print-command.png" alt="The Sed \`unambiguous print\`command">
<img src="https://i1.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-unambiguous-print-command.png" alt="The Sed \`unambiguous print\`command"></p>
<p>I suspect this command was once used to exchange data over non <a href="https://en.wikipedia.org/wiki/8-bit_clean">8-bits
clean channels</a>. As of
myself, I never used it for anything else than for debugging purposes.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="the-transliterate-command">The transliterate command</h3>
<p>The transliterate (<code>y</code>) command allows mapping characters of the pattern
space from a source set to a destination set. It is quite similar to the
<code>tr</code> command, although more limited.</p>
<p><img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-transliterate-command.png" alt="The Sed \`transliterate\`command">
<img src="https://i0.wp.com/linuxhandbook.com/wp-content/uploads/2018/05//sed-transliterate-command.png" alt="The Sed \`transliterate\`command"></p>
<pre><code># The `y` c0mm4nd 1s for h4x0rz only
sed &lt; inputfile -e '
  s/:.*//
  y/abcegio/48&lt;3610/
'
</code></pre>
<p>While the transliterate command syntax bears some resemblances with the
substitution command syntax, it does not accept any option after the
replacement string. The transliteration is always global.</p>
<p>Beware that the transliterate command requires all the characters both
in the original and destination set to be given verbatim. That means the
following Sed program does not do what you might think at first sight:</p>
<pre><code># BEWARE: this doesn't do what you may think!
sed &lt; inputfile -e '
  s/:.*//
  y/[a-z]/[A-Z]/
'
</code></pre>
<h2 id="the-last-word"><!-- raw HTML omitted --><!-- raw HTML omitted -->
The last word</h2>
<pre><code># What will this do?
# Hint: the answer is not far away...
sed -E '
  s/.*\W(.*)/\1/
  h
  ${ x; p; }
  d' &lt; inputfile
</code></pre>
<p>I can’t believe we did it! We’ve reviewed all the Sed commands. If you
reached that point, you deserve congratulations, especially if you took
the time to try the different examples on your system!</p>
<p>As you’ve seen, Sed is a complex beast, not only because of its sparse
syntax but also because of all the various corner cases or subtle
differences in the command behavior. No doubt, we can blame historical
reasons for that. Despite these drawbacks, it is a powerful tool and
like <a href="https://linuxhandbook.com/awk-command-tutorial/">AWK command</a>,
even today remains one of the most useful commands of the Unix toolbox.</p>
<p>If it is time for me to conclude that article, I wouldn’t do it without
first asking you a favor: please, share with us using the command
section your most favorite or creative piece of Sed script. If we have
enough of them, we could publish a compilation of those Sed gems!</p>

        </div>
        
          <div class="single-tags">
            
              <a class="single-tag" href="https://lsq.github.io/tags/sed">
                #sed
              </a>
            
          </div>
        
        <div class="separator"></div>
        


        

        

      </div>
    </div>
    <div class="col-md-3">
      <div id="toc">
        <h6>目录</h6>
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#a-little-bit-of-theory-on-sed">A little bit of theory on Sed</a></li>
        <li><a href="#a-first-look-at-the-sed-execution-model">A first look at the sed execution model</a></li>
        <li><a href="#the-sed-abstract-machine-a-namethesedabstractmachine-a">The Sed abstract machine </a></li>
        <li><a href="#a-more-accurate-sed-execution-model">A more accurate Sed execution model</a></li>
      </ul>
    </li>
    <li><a href="#the-print-command">The print command</a></li>
    <li><a href="#addresses">Addresses</a>
      <ul>
        <li><a href="#line-numbers">Line numbers</a></li>
        <li><a href="#regular-expressions">Regular expressions</a></li>
        <li><a href="#extended-regular-expressions">Extended regular expressions</a></li>
        <li><a href="#the-bracket-quantifier">The bracket quantifier</a></li>
        <li><a href="#range-addresses">Range addresses</a></li>
        <li><a href="#complement">Complement</a></li>
        <li><a href="#conjunctions">Conjunctions</a></li>
      </ul>
    </li>
    <li><a href="#the-quit-command">The quit command</a></li>
    <li><a href="#the-substitution-command">The substitution command</a>
      <ul>
        <li><a href="#the-delete-command">The delete command</a></li>
        <li><a href="#the-next-command">The next command</a></li>
      </ul>
    </li>
    <li><a href="#working-with-the-hold-space">Working with the hold space</a>
      <ul>
        <li><a href="#the-exchange-command">The exchange command</a></li>
        <li><a href="#the-hold-commands">The hold commands</a></li>
        <li><a href="#the-get-command">The get command</a></li>
      </ul>
    </li>
    <li><a href="#print-delete-and-next-revisited">print, delete and next revisited</a></li>
    <li><a href="#branching">Branching</a>
      <ul>
        <li><a href="#labels-and-branches">labels and branches</a></li>
        <li><a href="#conditional-branch">Conditional branch</a></li>
      </ul>
    </li>
    <li><a href="#handling-verbatim-text">Handling verbatim text</a>
      <ul>
        <li><a href="#the-change-command">The change command</a></li>
        <li><a href="#the-insert-command">The insert command</a></li>
        <li><a href="#the-append-command">The append command</a></li>
        <li><a href="#the-read-command">The read command</a></li>
      </ul>
    </li>
    <li><a href="#alternate-output">Alternate output</a>
      <ul>
        <li><a href="#the-write-command">The write command</a></li>
        <li><a href="#the-substitution-command-write-flag">The substitution command write flag</a></li>
      </ul>
    </li>
    <li><a href="#comments">Comments</a></li>
    <li><a href="#the-commands-you-will-rarely-need">The commands you will rarely need</a>
      <ul>
        <li><a href="#the-line-number-command">The line number command</a></li>
        <li><a href="#the-unambiguous-print-command">The unambiguous print command</a></li>
        <li><a href="#the-transliterate-command">The transliterate command</a></li>
      </ul>
    </li>
    <li><a href="#the-last-word">The last word</a></li>
  </ul>
</nav>
      </div>
    </div>
  </div>
</div>

<footer id="footer">
  <div class="container">
    
    
    
      
    
    © 2019
  </div>
</footer>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/Swiper/4.4.6/js/swiper.min.js"></script>
<script src="https://cdn.bootcss.com/smooth-scroll/15.2.0/smooth-scroll.polyfills.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script>
<script src="https://cdn.bootcss.com/clipboard.js/2.0.1/clipboard.min.js"></script>


<script src="/assets/app.min.js"></script>
<script>
  
  const search = instantsearch({
    appId: '2KA3KB1R4W',
    apiKey: '23b12e7862db67f7211e1016361bbe1c',
    indexName: 'often9',
  });
  search.addWidget(
    instantsearch.widgets.searchBox({
      container: '#search',
      magnifier: false,
      wrapInput: false,
      reset: false,
    })
  );
  search.addWidget(
    instantsearch.widgets.hits({
      container: '#search-content',
      templates: {
        item: function (data) {
          return (
            '<a href="' + "/" + data.uri + '" class="search-hit-item">' +
            data._highlightResult.title.value +
            '</a>'
          );
        },
      },
    })
  );
  search.start();
</script>
</body>
</html>
